# ğŸ› ï¸ çŒœæ•°å­—æ¸¸æˆå®ç°æ­¥éª¤æ€»ç»“

æœ¬æ–‡æ¡£æ€»ç»“äº†ä»é›¶å¼€å§‹å®ç° Go è¯­è¨€çŒœæ•°å­—æ¸¸æˆçš„å®Œæ•´æ­¥éª¤ï¼Œé€‚åˆä½œä¸ºå¿«é€Ÿå‚è€ƒå’Œå®è·µæŒ‡å—ã€‚

## ğŸ“‹ å®ç°æ£€æŸ¥æ¸…å•

### é˜¶æ®µä¸€ï¼šç¯å¢ƒå‡†å¤‡ âœ…
- [ ] å®‰è£… Go è¯­è¨€ç¯å¢ƒ
- [ ] é…ç½®å¼€å‘å·¥å…·ï¼ˆVS Code + Go æ‰©å±•ï¼‰
- [ ] åˆ›å»ºé¡¹ç›®ç›®å½•ç»“æ„
- [ ] åˆå§‹åŒ– Go æ¨¡å— (`go mod init`)
- [ ] éªŒè¯ç¯å¢ƒé…ç½®

### é˜¶æ®µäºŒï¼šåŸºç¡€å®ç° âœ…
- [ ] å®šä¹‰ Game ç»“æ„ä½“
- [ ] å®ç° NewGame æ„é€ å‡½æ•°
- [ ] å®ç°éšæœºæ•°ç”Ÿæˆé€»è¾‘
- [ ] å®ç° checkGuess æ–¹æ³•
- [ ] å®ç°åŸºæœ¬çš„ç”¨æˆ·è¾“å…¥å¤„ç†
- [ ] å®ç°æ¸¸æˆä¸»å¾ªç¯

### é˜¶æ®µä¸‰ï¼šå®Œå–„åŠŸèƒ½ âœ…
- [ ] æ·»åŠ è¾“å…¥éªŒè¯å’Œé”™è¯¯å¤„ç†
- [ ] å®ç°å¤šè½®æ¸¸æˆæ”¯æŒ
- [ ] ç¾åŒ–ç”¨æˆ·ç•Œé¢è¾“å‡º
- [ ] æ·»åŠ æ¸¸æˆç»Ÿè®¡åŠŸèƒ½
- [ ] å®ç°ç»§ç»­æ¸¸æˆè¯¢é—®

### é˜¶æ®µå››ï¼šæµ‹è¯•è¦†ç›– âœ…
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] æ·»åŠ åŸºå‡†æµ‹è¯•
- [ ] å®ç°æµ‹è¯•è¦†ç›–ç‡åˆ†æ
- [ ] æ·»åŠ è¾¹ç•Œæ¡ä»¶æµ‹è¯•
- [ ] å®ç°é›†æˆæµ‹è¯•

### é˜¶æ®µäº”ï¼šä¼˜åŒ–æ‰©å±• âœ…
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] æ·»åŠ éš¾åº¦çº§åˆ«
- [ ] å®ç°æˆå°±ç³»ç»Ÿ
- [ ] æ·»åŠ é…ç½®ç®¡ç†
- [ ] å®ç°å¤šè¯­è¨€æ”¯æŒ

## ğŸ”§ æ ¸å¿ƒä»£ç å®ç°æ­¥éª¤

### æ­¥éª¤ 1ï¼šåˆ›å»ºé¡¹ç›®ç»“æ„
```bash
mkdir go-guess-game
cd go-guess-game
go mod init guess-number-game
touch main.go main_test.go
mkdir docs
```

### æ­¥éª¤ 2ï¼šå®šä¹‰æ ¸å¿ƒç»“æ„ä½“
```go
type Game struct {
    targetNumber int           // ç›®æ ‡æ•°å­—
    attempts     int           // çŒœæµ‹æ¬¡æ•°
    scanner      *bufio.Scanner // è¾“å…¥æ‰«æå™¨
}
```

### æ­¥éª¤ 3ï¼šå®ç°æ„é€ å‡½æ•°
```go
func NewGame() *Game {
    rand.Seed(time.Now().UnixNano())
    return &Game{
        targetNumber: rand.Intn(100) + 1,
        attempts:     0,
        scanner:      bufio.NewScanner(os.Stdin),
    }
}
```

### æ­¥éª¤ 4ï¼šå®ç°æ ¸å¿ƒæ¸¸æˆé€»è¾‘
```go
func (g *Game) checkGuess(guess int) int {
    if guess == g.targetNumber {
        return 0  // çŒœå¯¹äº†
    } else if guess > g.targetNumber {
        return 1  // çŒœå¤§äº†
    } else {
        return -1 // çŒœå°äº†
    }
}
```

### æ­¥éª¤ 5ï¼šå®ç°è¾“å…¥å¤„ç†
```go
func (g *Game) getPlayerGuess() (int, error) {
    fmt.Print("è¯·è¾“å…¥ä½ çš„çŒœæµ‹ï¼š")
    
    if !g.scanner.Scan() {
        return 0, fmt.Errorf("è¯»å–è¾“å…¥å¤±è´¥")
    }
    
    input := strings.TrimSpace(g.scanner.Text())
    if input == "" {
        return 0, fmt.Errorf("è¾“å…¥ä¸èƒ½ä¸ºç©º")
    }
    
    guess, err := strconv.Atoi(input)
    if err != nil {
        return 0, fmt.Errorf("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„æ•°å­—")
    }
    
    if guess < 1 || guess > 100 {
        return 0, fmt.Errorf("æ•°å­—å¿…é¡»åœ¨ 1-100 ä¹‹é—´")
    }
    
    return guess, nil
}
```

### æ­¥éª¤ 6ï¼šå®ç°æ¸¸æˆä¸»å¾ªç¯
```go
func (g *Game) Start() {
    fmt.Println("æ¬¢è¿æ¥åˆ°çŒœæ•°å­—æ¸¸æˆï¼")
    fmt.Println("æˆ‘å·²ç»æƒ³å¥½äº†ä¸€ä¸ª 1-100 ä¹‹é—´çš„æ•°å­—ï¼Œè¯·å¼€å§‹çŒœæµ‹ï¼š")
    
    for {
        guess, err := g.getPlayerGuess()
        if err != nil {
            fmt.Printf("è¾“å…¥é”™è¯¯ï¼š%vï¼Œè¯·é‡æ–°è¾“å…¥ã€‚\n", err)
            continue
        }
        
        g.attempts++
        result := g.checkGuess(guess)
        
        if result == 0 {
            fmt.Printf("æ­å–œä½ ï¼çŒœå¯¹äº†ï¼ä½ æ€»å…±çŒœäº† %d æ¬¡ã€‚\n", g.attempts)
            break
        } else if result > 0 {
            fmt.Println("å¤ªå¤§äº†ï¼è¯·å†è¯•ä¸€æ¬¡ã€‚")
        } else {
            fmt.Println("å¤ªå°äº†ï¼è¯·å†è¯•ä¸€æ¬¡ã€‚")
        }
    }
}
```

### æ­¥éª¤ 7ï¼šå®ç°ä¸»å‡½æ•°
```go
func main() {
    fmt.Println(strings.Repeat("=", 50))
    fmt.Println("ğŸ¯ Go è¯­è¨€çŒœæ•°å­—æ¸¸æˆ")
    fmt.Println(strings.Repeat("=", 50))

    for {
        game := NewGame()
        game.Start()

        if !askContinue() {
            fmt.Println("æ„Ÿè°¢æ¸¸æˆï¼å†è§ï¼ğŸ‘‹")
            break
        }

        fmt.Println("\n" + strings.Repeat("=", 30))
        fmt.Println("å¼€å§‹æ–°æ¸¸æˆï¼")
        fmt.Println(strings.Repeat("=", 30))
    }
}
```

## ğŸ§ª æµ‹è¯•å®ç°æ­¥éª¤

### æ­¥éª¤ 1ï¼šåŸºç¡€æµ‹è¯•ç»“æ„
```go
func TestNewGame(t *testing.T) {
    game := NewGame()
    
    if game == nil {
        t.Fatal("NewGame() è¿”å›äº† nil")
    }
    
    if game.targetNumber < 1 || game.targetNumber > 100 {
        t.Errorf("ç›®æ ‡æ•°å­— %d ä¸åœ¨ 1-100 èŒƒå›´å†…", game.targetNumber)
    }
    
    if game.attempts != 0 {
        t.Errorf("åˆå§‹çŒœæµ‹æ¬¡æ•°åº”è¯¥ä¸º 0ï¼Œå®é™…ä¸º %d", game.attempts)
    }
}
```

### æ­¥éª¤ 2ï¼šé€»è¾‘æµ‹è¯•
```go
func TestCheckGuess(t *testing.T) {
    game := &Game{targetNumber: 50, attempts: 0}
    
    testCases := []struct {
        name     string
        guess    int
        expected int
    }{
        {"çŒœå¯¹äº†", 50, 0},
        {"çŒœå¤§äº†", 75, 1},
        {"çŒœå°äº†", 25, -1},
    }
    
    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            result := game.checkGuess(tc.guess)
            if result != tc.expected {
                t.Errorf("çŒœæµ‹ %d æ—¶ï¼ŒæœŸæœ›è¿”å› %dï¼Œå®é™…è¿”å› %d", 
                    tc.guess, tc.expected, result)
            }
        })
    }
}
```

### æ­¥éª¤ 3ï¼šåŸºå‡†æµ‹è¯•
```go
func BenchmarkNewGame(b *testing.B) {
    for i := 0; i < b.N; i++ {
        NewGame()
    }
}

func BenchmarkCheckGuess(b *testing.B) {
    game := &Game{targetNumber: 50}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        game.checkGuess(25)
    }
}
```

## ğŸš€ ç¼–è¯‘å’Œè¿è¡Œæ­¥éª¤

### å¼€å‘é˜¶æ®µ
```bash
# ç›´æ¥è¿è¡Œæºç 
go run main.go

# è¿è¡Œæµ‹è¯•
go test -v

# è¿è¡ŒåŸºå‡†æµ‹è¯•
go test -bench=.

# æŸ¥çœ‹æµ‹è¯•è¦†ç›–ç‡
go test -cover
```

### ç”Ÿäº§éƒ¨ç½²
```bash
# ç¼–è¯‘ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶
go build -o guess-game main.go

# è¿è¡Œç¼–è¯‘åçš„ç¨‹åº
./guess-game

# äº¤å‰ç¼–è¯‘ï¼ˆä¾‹å¦‚ä¸º Windows ç¼–è¯‘ï¼‰
GOOS=windows GOARCH=amd64 go build -o guess-game.exe main.go
```

## ğŸ“Š é¡¹ç›®è´¨é‡æ£€æŸ¥

### ä»£ç è´¨é‡æ£€æŸ¥
```bash
# æ ¼å¼åŒ–ä»£ç 
go fmt ./...

# é™æ€åˆ†æ
go vet ./...

# æ£€æŸ¥ä¾èµ–
go mod tidy
go mod verify
```

### æ€§èƒ½åˆ†æ
```bash
# CPU æ€§èƒ½åˆ†æ
go test -cpuprofile=cpu.prof -bench=.
go tool pprof cpu.prof

# å†…å­˜åˆ†æ
go test -memprofile=mem.prof -bench=.
go tool pprof mem.prof
```

## ğŸ”„ è¿­ä»£å¼€å‘æµç¨‹

### ç‰ˆæœ¬ 1.0ï¼šåŸºç¡€åŠŸèƒ½
- [x] åŸºæœ¬æ¸¸æˆé€»è¾‘
- [x] ç®€å•ç”¨æˆ·äº¤äº’
- [x] åŸºç¡€é”™è¯¯å¤„ç†

### ç‰ˆæœ¬ 2.0ï¼šåŠŸèƒ½å¢å¼º
- [x] å®Œå–„çš„è¾“å…¥éªŒè¯
- [x] ç¾åŒ–çš„ç”¨æˆ·ç•Œé¢
- [x] å¤šè½®æ¸¸æˆæ”¯æŒ

### ç‰ˆæœ¬ 3.0ï¼šæµ‹è¯•è¦†ç›–
- [x] å•å…ƒæµ‹è¯•
- [x] åŸºå‡†æµ‹è¯•
- [x] æµ‹è¯•è¦†ç›–ç‡åˆ†æ

### ç‰ˆæœ¬ 4.0ï¼šé«˜çº§åŠŸèƒ½
- [x] éš¾åº¦çº§åˆ«ç³»ç»Ÿ
- [x] æ¸¸æˆç»Ÿè®¡åŠŸèƒ½
- [x] æˆå°±ç³»ç»Ÿ

### ç‰ˆæœ¬ 5.0ï¼šæ¶æ„ä¼˜åŒ–
- [x] ä»£ç é‡æ„
- [x] æ¥å£åˆ†ç¦»
- [x] ä¾èµ–æ³¨å…¥

## ğŸ¯ å­¦ä¹ æˆæœéªŒè¯

å®Œæˆæœ¬é¡¹ç›®åï¼Œæ‚¨åº”è¯¥èƒ½å¤Ÿï¼š

### Go è¯­è¨€åŸºç¡€
- âœ… ç†Ÿç»ƒä½¿ç”¨ Go è¯­è¨€åŸºæœ¬è¯­æ³•
- âœ… ç†è§£ Go è¯­è¨€çš„ç±»å‹ç³»ç»Ÿ
- âœ… æŒæ¡é”™è¯¯å¤„ç†æœºåˆ¶
- âœ… ç†Ÿæ‚‰æ ‡å‡†åº“çš„ä½¿ç”¨

### ç¼–ç¨‹å®è·µ
- âœ… ç¼–å†™æ¸…æ™°ã€å¯ç»´æŠ¤çš„ä»£ç 
- âœ… å®ç°å®Œæ•´çš„æµ‹è¯•è¦†ç›–
- âœ… åº”ç”¨é¢å‘å¯¹è±¡è®¾è®¡åŸåˆ™
- âœ… è¿›è¡Œæ€§èƒ½ä¼˜åŒ–

### è½¯ä»¶å·¥ç¨‹
- âœ… é¡¹ç›®ç»“æ„ç»„ç»‡
- âœ… ç‰ˆæœ¬æ§åˆ¶ä½¿ç”¨
- âœ… æ–‡æ¡£ç¼–å†™
- âœ… ä»£ç é‡æ„æŠ€å·§

## ğŸ”— ç›¸å…³èµ„æº

- [é¡¹ç›®æºç ](../main.go)
- [æµ‹è¯•æ–‡ä»¶](../main_test.go)
- [å®Œæ•´æ–‡æ¡£](./README.md)
- [Go å®˜æ–¹æ–‡æ¡£](https://golang.org/doc/)

## ğŸ‰ ä¸‹ä¸€æ­¥å»ºè®®

1. **æ‰©å±•åŠŸèƒ½**ï¼šæ·»åŠ æ›´å¤šæ¸¸æˆæ¨¡å¼å’ŒåŠŸèƒ½
2. **Web ç‰ˆæœ¬**ï¼šä½¿ç”¨ Go Web æ¡†æ¶åˆ›å»ºç½‘é¡µç‰ˆ
3. **æ•°æ®åº“é›†æˆ**ï¼šæ·»åŠ ç”¨æˆ·ç³»ç»Ÿå’Œæ•°æ®æŒä¹…åŒ–
4. **å¾®æœåŠ¡æ¶æ„**ï¼šå°†æ¸¸æˆæ‹†åˆ†ä¸ºå¤šä¸ªæœåŠ¡
5. **ç§»åŠ¨åº”ç”¨**ï¼šä½¿ç”¨ Go Mobile åˆ›å»ºç§»åŠ¨ç‰ˆæœ¬

æ­å–œæ‚¨å®Œæˆäº† Go è¯­è¨€çŒœæ•°å­—æ¸¸æˆçš„å®Œæ•´å®ç°ï¼ğŸŠ
