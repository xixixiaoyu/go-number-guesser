# ğŸ¤ ç”¨æˆ·äº¤äº’ä¸é”™è¯¯å¤„ç†

æœ¬ç« å°†æ·±å…¥å­¦ä¹ å¦‚ä½•è®¾è®¡å‹å¥½çš„ç”¨æˆ·äº¤äº’ç•Œé¢å’Œå®ç°å¥å£®çš„é”™è¯¯å¤„ç†æœºåˆ¶ã€‚

## 1. ç”¨æˆ·äº¤äº’è®¾è®¡åŸåˆ™

### ç”¨æˆ·ä½“éªŒè®¾è®¡è¦ç‚¹
1. **æ¸…æ™°çš„æç¤ºä¿¡æ¯**ï¼šç”¨æˆ·çŸ¥é“è¯¥åšä»€ä¹ˆ
2. **åŠæ—¶çš„åé¦ˆ**ï¼šç”¨æˆ·çŸ¥é“å‘ç”Ÿäº†ä»€ä¹ˆ
3. **å®¹é”™æ€§**ï¼šå…è®¸ç”¨æˆ·çŠ¯é”™å¹¶æä¾›çº æ­£æœºä¼š
4. **ä¸€è‡´æ€§**ï¼šç›¸ä¼¼çš„æ“ä½œæœ‰ç›¸ä¼¼çš„äº¤äº’æ–¹å¼

### äº¤äº’æµç¨‹è®¾è®¡
```go
// ç”¨æˆ·äº¤äº’çš„åŸºæœ¬æµç¨‹
func (g *Game) interactWithUser() {
    // 1. æ˜¾ç¤ºæç¤ºä¿¡æ¯
    g.showPrompt()
    
    // 2. è·å–ç”¨æˆ·è¾“å…¥
    input, err := g.getUserInput()
    
    // 3. éªŒè¯è¾“å…¥
    if err != nil {
        g.showError(err)
        return
    }
    
    // 4. å¤„ç†è¾“å…¥
    result := g.processInput(input)
    
    // 5. æ˜¾ç¤ºåé¦ˆ
    g.showFeedback(result)
}
```

## 2. è¾“å…¥å¤„ç†ä¼˜åŒ–

### é«˜çº§è¾“å…¥å¤„ç†
```go
import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
    "unicode"
)

// InputHandler è¾“å…¥å¤„ç†å™¨
type InputHandler struct {
    scanner *bufio.Scanner
}

// NewInputHandler åˆ›å»ºè¾“å…¥å¤„ç†å™¨
func NewInputHandler() *InputHandler {
    return &InputHandler{
        scanner: bufio.NewScanner(os.Stdin),
    }
}

// ReadLine è¯»å–ä¸€è¡Œè¾“å…¥
func (ih *InputHandler) ReadLine() (string, error) {
    if !ih.scanner.Scan() {
        if err := ih.scanner.Err(); err != nil {
            return "", fmt.Errorf("è¯»å–è¾“å…¥æ—¶å‘ç”Ÿé”™è¯¯: %v", err)
        }
        return "", fmt.Errorf("è¾“å…¥æµå·²ç»“æŸ")
    }
    return ih.scanner.Text(), nil
}

// ReadInt è¯»å–æ•´æ•°è¾“å…¥
func (ih *InputHandler) ReadInt(prompt string) (int, error) {
    fmt.Print(prompt)
    
    line, err := ih.ReadLine()
    if err != nil {
        return 0, err
    }
    
    // æ¸…ç†è¾“å…¥
    cleaned := strings.TrimSpace(line)
    if cleaned == "" {
        return 0, fmt.Errorf("è¾“å…¥ä¸èƒ½ä¸ºç©º")
    }
    
    // è½¬æ¢ä¸ºæ•´æ•°
    num, err := strconv.Atoi(cleaned)
    if err != nil {
        return 0, fmt.Errorf("'%s' ä¸æ˜¯æœ‰æ•ˆçš„æ•°å­—", cleaned)
    }
    
    return num, nil
}

// ReadIntInRange è¯»å–æŒ‡å®šèŒƒå›´å†…çš„æ•´æ•°
func (ih *InputHandler) ReadIntInRange(prompt string, min, max int) (int, error) {
    for {
        num, err := ih.ReadInt(prompt)
        if err != nil {
            return 0, err
        }
        
        if num < min || num > max {
            fmt.Printf("æ•°å­—å¿…é¡»åœ¨ %d-%d ä¹‹é—´ï¼Œè¯·é‡æ–°è¾“å…¥ã€‚\n", min, max)
            continue
        }
        
        return num, nil
    }
}
```

### æ™ºèƒ½è¾“å…¥è§£æ
```go
// parseUserInput æ™ºèƒ½è§£æç”¨æˆ·è¾“å…¥
func parseUserInput(input string) (int, error) {
    // æ¸…ç†è¾“å…¥
    cleaned := strings.TrimSpace(input)
    if cleaned == "" {
        return 0, fmt.Errorf("è¾“å…¥ä¸èƒ½ä¸ºç©º")
    }
    
    // æ£€æŸ¥æ˜¯å¦åŒ…å«éæ•°å­—å­—ç¬¦
    for _, r := range cleaned {
        if !unicode.IsDigit(r) && r != '-' && r != '+' {
            return 0, fmt.Errorf("è¾“å…¥åŒ…å«æ— æ•ˆå­—ç¬¦: '%c'", r)
        }
    }
    
    // è½¬æ¢ä¸ºæ•°å­—
    num, err := strconv.Atoi(cleaned)
    if err != nil {
        return 0, fmt.Errorf("æ— æ³•è§£ææ•°å­—: %v", err)
    }
    
    return num, nil
}

// æ”¯æŒä¸­æ–‡æ•°å­—çš„è§£æï¼ˆæ‰©å±•åŠŸèƒ½ï¼‰
func parseChineseNumber(input string) (int, error) {
    chineseNumbers := map[string]int{
        "ä¸€": 1, "äºŒ": 2, "ä¸‰": 3, "å››": 4, "äº”": 5,
        "å…­": 6, "ä¸ƒ": 7, "å…«": 8, "ä¹": 9, "å": 10,
        "é›¶": 0,
    }
    
    if num, exists := chineseNumbers[input]; exists {
        return num, nil
    }
    
    return parseUserInput(input)
}
```

## 3. é”™è¯¯å¤„ç†ç­–ç•¥

### é”™è¯¯åˆ†ç±»å’Œå¤„ç†
```go
// å®šä¹‰é”™è¯¯ç±»å‹
type GameError struct {
    Type    string
    Message string
    Code    int
}

func (e *GameError) Error() string {
    return fmt.Sprintf("[%s] %s (ä»£ç : %d)", e.Type, e.Message, e.Code)
}

// é”™è¯¯ç±»å‹å¸¸é‡
const (
    ErrorTypeInput      = "è¾“å…¥é”™è¯¯"
    ErrorTypeValidation = "éªŒè¯é”™è¯¯"
    ErrorTypeSystem     = "ç³»ç»Ÿé”™è¯¯"
)

// åˆ›å»ºç‰¹å®šç±»å‹çš„é”™è¯¯
func NewInputError(message string) *GameError {
    return &GameError{
        Type:    ErrorTypeInput,
        Message: message,
        Code:    1001,
    }
}

func NewValidationError(message string) *GameError {
    return &GameError{
        Type:    ErrorTypeValidation,
        Message: message,
        Code:    2001,
    }
}

func NewSystemError(message string) *GameError {
    return &GameError{
        Type:    ErrorTypeSystem,
        Message: message,
        Code:    3001,
    }
}
```

### é”™è¯¯æ¢å¤æœºåˆ¶
```go
// RetryableOperation å¯é‡è¯•çš„æ“ä½œ
type RetryableOperation func() error

// retryWithLimit å¸¦é™åˆ¶çš„é‡è¯•æœºåˆ¶
func retryWithLimit(operation RetryableOperation, maxRetries int) error {
    var lastErr error
    
    for i := 0; i <= maxRetries; i++ {
        if err := operation(); err != nil {
            lastErr = err
            if i < maxRetries {
                fmt.Printf("æ“ä½œå¤±è´¥ï¼Œæ­£åœ¨é‡è¯•... (%d/%d)\n", i+1, maxRetries)
                continue
            }
        } else {
            return nil // æˆåŠŸ
        }
    }
    
    return fmt.Errorf("æ“ä½œå¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•° (%d): %v", maxRetries, lastErr)
}

// ä½¿ç”¨ç¤ºä¾‹
func (g *Game) getValidInput() (int, error) {
    return retryWithLimit(func() error {
        guess, err := g.inputHandler.ReadIntInRange("è¯·è¾“å…¥çŒœæµ‹ (1-100): ", 1, 100)
        if err != nil {
            return err
        }
        g.currentGuess = guess
        return nil
    }, 3)
}
```

## 4. ç”¨æˆ·ç•Œé¢è®¾è®¡

### æ§åˆ¶å°ç•Œé¢ç¾åŒ–
```go
import (
    "fmt"
    "strings"
)

// UIManager ç”¨æˆ·ç•Œé¢ç®¡ç†å™¨
type UIManager struct {
    width int // ç•Œé¢å®½åº¦
}

// NewUIManager åˆ›å»ºç•Œé¢ç®¡ç†å™¨
func NewUIManager(width int) *UIManager {
    return &UIManager{width: width}
}

// DrawBorder ç»˜åˆ¶è¾¹æ¡†
func (ui *UIManager) DrawBorder(char string) {
    fmt.Println(strings.Repeat(char, ui.width))
}

// DrawTitle ç»˜åˆ¶æ ‡é¢˜
func (ui *UIManager) DrawTitle(title string) {
    ui.DrawBorder("=")
    padding := (ui.width - len(title)) / 2
    fmt.Printf("%s%s%s\n", 
        strings.Repeat(" ", padding), 
        title, 
        strings.Repeat(" ", ui.width-padding-len(title)))
    ui.DrawBorder("=")
}

// DrawSection ç»˜åˆ¶ç« èŠ‚
func (ui *UIManager) DrawSection(title string) {
    fmt.Printf("\n%s %s %s\n", 
        strings.Repeat("-", 5), 
        title, 
        strings.Repeat("-", ui.width-len(title)-12))
}

// DrawBox ç»˜åˆ¶ä¿¡æ¯æ¡†
func (ui *UIManager) DrawBox(content []string) {
    ui.DrawBorder("+")
    for _, line := range content {
        fmt.Printf("| %-*s |\n", ui.width-4, line)
    }
    ui.DrawBorder("+")
}

// ä½¿ç”¨ç¤ºä¾‹
func (g *Game) displayWelcomeScreen() {
    ui := NewUIManager(60)
    
    ui.DrawTitle("ğŸ¯ Go è¯­è¨€çŒœæ•°å­—æ¸¸æˆ")
    
    ui.DrawSection("æ¸¸æˆè§„åˆ™")
    rules := []string{
        "1. ç³»ç»Ÿä¼šéšæœºç”Ÿæˆä¸€ä¸ª 1-100 ä¹‹é—´çš„æ•°å­—",
        "2. ä½ éœ€è¦é€šè¿‡çŒœæµ‹æ¥æ‰¾åˆ°è¿™ä¸ªæ•°å­—",
        "3. ç³»ç»Ÿä¼šæç¤ºä½ çš„çŒœæµ‹æ˜¯å¤ªå¤§è¿˜æ˜¯å¤ªå°",
        "4. å°½é‡ç”¨æœ€å°‘çš„æ¬¡æ•°çŒœä¸­ç›®æ ‡æ•°å­—ï¼",
    }
    ui.DrawBox(rules)
    
    ui.DrawSection("æ“ä½œæç¤º")
    tips := []string{
        "â€¢ è¾“å…¥æ•°å­—è¿›è¡ŒçŒœæµ‹",
        "â€¢ è¾“å…¥ 'help' æŸ¥çœ‹å¸®åŠ©",
        "â€¢ è¾“å…¥ 'quit' é€€å‡ºæ¸¸æˆ",
    }
    ui.DrawBox(tips)
    
    fmt.Println("\næŒ‰å›è½¦é”®å¼€å§‹æ¸¸æˆ...")
    fmt.Scanln()
}
```

### åŠ¨æ€è¿›åº¦æ˜¾ç¤º
```go
// ProgressBar è¿›åº¦æ¡
type ProgressBar struct {
    total   int
    current int
    width   int
}

// NewProgressBar åˆ›å»ºè¿›åº¦æ¡
func NewProgressBar(total, width int) *ProgressBar {
    return &ProgressBar{
        total: total,
        width: width,
    }
}

// Update æ›´æ–°è¿›åº¦
func (pb *ProgressBar) Update(current int) {
    pb.current = current
    pb.Draw()
}

// Draw ç»˜åˆ¶è¿›åº¦æ¡
func (pb *ProgressBar) Draw() {
    percentage := float64(pb.current) / float64(pb.total)
    filled := int(percentage * float64(pb.width))
    
    bar := strings.Repeat("â–ˆ", filled) + strings.Repeat("â–‘", pb.width-filled)
    fmt.Printf("\rè¿›åº¦: [%s] %d/%d (%.1f%%)", 
        bar, pb.current, pb.total, percentage*100)
}

// æ¸¸æˆä¸­ä½¿ç”¨è¿›åº¦æ¡æ˜¾ç¤ºçŒœæµ‹æ¬¡æ•°
func (g *Game) showAttemptProgress() {
    maxAttempts := 10 // å‡è®¾æœ€å¤§çŒœæµ‹æ¬¡æ•°ä¸º10
    pb := NewProgressBar(maxAttempts, 30)
    pb.Update(g.attempts)
    fmt.Println()
}
```

## 5. äº¤äº’å¼å¸®åŠ©ç³»ç»Ÿ

### å¸®åŠ©ç³»ç»Ÿå®ç°
```go
// HelpSystem å¸®åŠ©ç³»ç»Ÿ
type HelpSystem struct {
    topics map[string]string
}

// NewHelpSystem åˆ›å»ºå¸®åŠ©ç³»ç»Ÿ
func NewHelpSystem() *HelpSystem {
    hs := &HelpSystem{
        topics: make(map[string]string),
    }
    hs.initializeTopics()
    return hs
}

// initializeTopics åˆå§‹åŒ–å¸®åŠ©ä¸»é¢˜
func (hs *HelpSystem) initializeTopics() {
    hs.topics["rules"] = `
æ¸¸æˆè§„åˆ™ï¼š
1. ç³»ç»Ÿéšæœºç”Ÿæˆä¸€ä¸ª 1-100 ä¹‹é—´çš„æ•°å­—
2. ä½ éœ€è¦çŒœå‡ºè¿™ä¸ªæ•°å­—
3. ç³»ç»Ÿä¼šå‘Šè¯‰ä½ çŒœæµ‹æ˜¯å¤ªå¤§è¿˜æ˜¯å¤ªå°
4. å°½é‡ç”¨æœ€å°‘çš„æ¬¡æ•°çŒœä¸­ï¼
`
    
    hs.topics["commands"] = `
å¯ç”¨å‘½ä»¤ï¼š
â€¢ è¾“å…¥æ•°å­— (1-100) - è¿›è¡ŒçŒœæµ‹
â€¢ help - æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
â€¢ hint - è·å–æç¤ºï¼ˆ5æ¬¡çŒœæµ‹åå¯ç”¨ï¼‰
â€¢ stats - æ˜¾ç¤ºå½“å‰æ¸¸æˆç»Ÿè®¡
â€¢ quit - é€€å‡ºæ¸¸æˆ
`
    
    hs.topics["tips"] = `
æ¸¸æˆæŠ€å·§ï¼š
â€¢ ä½¿ç”¨äºŒåˆ†æ³•ï¼šä»50å¼€å§‹çŒœæµ‹
â€¢ æ ¹æ®åé¦ˆç¼©å°èŒƒå›´
â€¢ è®°ä½ä¹‹å‰çš„çŒœæµ‹ç»“æœ
â€¢ ä¿æŒå†·é™ï¼Œé€»è¾‘æ€è€ƒ
`
}

// ShowHelp æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
func (hs *HelpSystem) ShowHelp(topic string) {
    if topic == "" {
        hs.showAllTopics()
        return
    }
    
    if content, exists := hs.topics[topic]; exists {
        fmt.Println(content)
    } else {
        fmt.Printf("æœªæ‰¾åˆ°å¸®åŠ©ä¸»é¢˜ '%s'ã€‚å¯ç”¨ä¸»é¢˜ï¼š\n", topic)
        for t := range hs.topics {
            fmt.Printf("â€¢ %s\n", t)
        }
    }
}

// showAllTopics æ˜¾ç¤ºæ‰€æœ‰å¸®åŠ©ä¸»é¢˜
func (hs *HelpSystem) showAllTopics() {
    fmt.Println("ğŸ“– æ¸¸æˆå¸®åŠ©")
    fmt.Println("å¯ç”¨çš„å¸®åŠ©ä¸»é¢˜ï¼š")
    for topic := range hs.topics {
        fmt.Printf("â€¢ help %s\n", topic)
    }
    fmt.Println("\nè¾“å…¥ 'help <ä¸»é¢˜>' æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯")
}
```

## 6. è¾“å…¥éªŒè¯å¢å¼º

### é«˜çº§éªŒè¯å™¨
```go
// Validator éªŒè¯å™¨æ¥å£
type Validator interface {
    Validate(input string) error
}

// RangeValidator èŒƒå›´éªŒè¯å™¨
type RangeValidator struct {
    Min int
    Max int
}

func (rv *RangeValidator) Validate(input string) error {
    num, err := strconv.Atoi(strings.TrimSpace(input))
    if err != nil {
        return fmt.Errorf("è¾“å…¥å¿…é¡»æ˜¯æ•°å­—")
    }
    
    if num < rv.Min || num > rv.Max {
        return fmt.Errorf("æ•°å­—å¿…é¡»åœ¨ %d-%d ä¹‹é—´", rv.Min, rv.Max)
    }
    
    return nil
}

// LengthValidator é•¿åº¦éªŒè¯å™¨
type LengthValidator struct {
    MaxLength int
}

func (lv *LengthValidator) Validate(input string) error {
    if len(input) > lv.MaxLength {
        return fmt.Errorf("è¾“å…¥é•¿åº¦ä¸èƒ½è¶…è¿‡ %d ä¸ªå­—ç¬¦", lv.MaxLength)
    }
    return nil
}

// CompositeValidator ç»„åˆéªŒè¯å™¨
type CompositeValidator struct {
    validators []Validator
}

func (cv *CompositeValidator) AddValidator(v Validator) {
    cv.validators = append(cv.validators, v)
}

func (cv *CompositeValidator) Validate(input string) error {
    for _, validator := range cv.validators {
        if err := validator.Validate(input); err != nil {
            return err
        }
    }
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func (g *Game) getValidatedInput() (int, error) {
    validator := &CompositeValidator{}
    validator.AddValidator(&LengthValidator{MaxLength: 3})
    validator.AddValidator(&RangeValidator{Min: 1, Max: 100})
    
    for {
        fmt.Print("è¯·è¾“å…¥çŒœæµ‹ (1-100): ")
        input, err := g.inputHandler.ReadLine()
        if err != nil {
            return 0, err
        }
        
        if err := validator.Validate(input); err != nil {
            fmt.Printf("âŒ %v\n", err)
            continue
        }
        
        num, _ := strconv.Atoi(strings.TrimSpace(input))
        return num, nil
    }
}
```

## 7. é”™è¯¯æ—¥å¿—è®°å½•

### ç®€å•æ—¥å¿—ç³»ç»Ÿ
```go
import (
    "log"
    "os"
    "time"
)

// Logger æ—¥å¿—è®°å½•å™¨
type Logger struct {
    *log.Logger
    file *os.File
}

// NewLogger åˆ›å»ºæ—¥å¿—è®°å½•å™¨
func NewLogger(filename string) (*Logger, error) {
    file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        return nil, err
    }
    
    logger := log.New(file, "", log.LstdFlags)
    return &Logger{
        Logger: logger,
        file:   file,
    }, nil
}

// LogError è®°å½•é”™è¯¯
func (l *Logger) LogError(err error) {
    l.Printf("ERROR: %v", err)
}

// LogInfo è®°å½•ä¿¡æ¯
func (l *Logger) LogInfo(message string) {
    l.Printf("INFO: %s", message)
}

// Close å…³é—­æ—¥å¿—æ–‡ä»¶
func (l *Logger) Close() error {
    return l.file.Close()
}

// åœ¨æ¸¸æˆä¸­ä½¿ç”¨æ—¥å¿—
func (g *Game) handleError(err error) {
    if g.logger != nil {
        g.logger.LogError(err)
    }
    fmt.Printf("âŒ %v\n", err)
}
```

## 8. å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šå®ç°å‘½ä»¤è§£æå™¨
```go
type Command struct {
    Name        string
    Description string
    Handler     func(args []string) error
}

type CommandParser struct {
    commands map[string]*Command
}

func (cp *CommandParser) AddCommand(cmd *Command) {
    cp.commands[cmd.Name] = cmd
}

func (cp *CommandParser) Parse(input string) error {
    parts := strings.Fields(input)
    if len(parts) == 0 {
        return fmt.Errorf("è¯·è¾“å…¥å‘½ä»¤")
    }
    
    cmdName := parts[0]
    args := parts[1:]
    
    if cmd, exists := cp.commands[cmdName]; exists {
        return cmd.Handler(args)
    }
    
    return fmt.Errorf("æœªçŸ¥å‘½ä»¤: %s", cmdName)
}
```

### ç»ƒä¹ 2ï¼šå®ç°è¾“å…¥å†å²è®°å½•
```go
type InputHistory struct {
    history []string
    maxSize int
    current int
}

func (ih *InputHistory) Add(input string) {
    if len(ih.history) >= ih.maxSize {
        ih.history = ih.history[1:]
    }
    ih.history = append(ih.history, input)
    ih.current = len(ih.history)
}

func (ih *InputHistory) GetPrevious() string {
    if ih.current > 0 {
        ih.current--
        return ih.history[ih.current]
    }
    return ""
}
```

## å°ç»“

æœ¬ç« å­¦ä¹ äº†ï¼š

1. **ç”¨æˆ·äº¤äº’è®¾è®¡**ï¼šæ¸…æ™°çš„æç¤ºã€åŠæ—¶çš„åé¦ˆã€è‰¯å¥½çš„å®¹é”™æ€§
2. **é«˜çº§è¾“å…¥å¤„ç†**ï¼šæ™ºèƒ½è§£æã€éªŒè¯æœºåˆ¶ã€é”™è¯¯æ¢å¤
3. **é”™è¯¯å¤„ç†ç­–ç•¥**ï¼šé”™è¯¯åˆ†ç±»ã€é‡è¯•æœºåˆ¶ã€æ—¥å¿—è®°å½•
4. **ç•Œé¢ç¾åŒ–**ï¼šæ§åˆ¶å°ç•Œé¢è®¾è®¡ã€è¿›åº¦æ˜¾ç¤º
5. **å¸®åŠ©ç³»ç»Ÿ**ï¼šäº¤äº’å¼å¸®åŠ©ã€å‘½ä»¤è§£æ

è‰¯å¥½çš„ç”¨æˆ·äº¤äº’å’Œé”™è¯¯å¤„ç†æ˜¯ä¼˜ç§€è½¯ä»¶çš„é‡è¦ç‰¹å¾ã€‚

## ä¸‹ä¸€æ­¥

ç»§ç»­å­¦ä¹ ï¼š[06-æµ‹è¯•é©±åŠ¨å¼€å‘.md](./06-æµ‹è¯•é©±åŠ¨å¼€å‘.md)

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•ç¼–å†™æµ‹è¯•æ¥ç¡®ä¿ä»£ç è´¨é‡ã€‚
