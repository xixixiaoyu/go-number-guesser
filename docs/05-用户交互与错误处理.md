# 🤝 用户交互与错误处理

本章将深入学习如何设计友好的用户交互界面和实现健壮的错误处理机制。

## 1. 用户交互设计原则

### 用户体验设计要点
1. **清晰的提示信息**：用户知道该做什么
2. **及时的反馈**：用户知道发生了什么
3. **容错性**：允许用户犯错并提供纠正机会
4. **一致性**：相似的操作有相似的交互方式

### 交互流程设计
```go
// 用户交互的基本流程
func (g *Game) interactWithUser() {
    // 1. 显示提示信息
    g.showPrompt()
    
    // 2. 获取用户输入
    input, err := g.getUserInput()
    
    // 3. 验证输入
    if err != nil {
        g.showError(err)
        return
    }
    
    // 4. 处理输入
    result := g.processInput(input)
    
    // 5. 显示反馈
    g.showFeedback(result)
}
```

## 2. 输入处理优化

### 高级输入处理
```go
import (
    "bufio"
    "fmt"
    "os"
    "strconv"
    "strings"
    "unicode"
)

// InputHandler 输入处理器
type InputHandler struct {
    scanner *bufio.Scanner
}

// NewInputHandler 创建输入处理器
func NewInputHandler() *InputHandler {
    return &InputHandler{
        scanner: bufio.NewScanner(os.Stdin),
    }
}

// ReadLine 读取一行输入
func (ih *InputHandler) ReadLine() (string, error) {
    if !ih.scanner.Scan() {
        if err := ih.scanner.Err(); err != nil {
            return "", fmt.Errorf("读取输入时发生错误: %v", err)
        }
        return "", fmt.Errorf("输入流已结束")
    }
    return ih.scanner.Text(), nil
}

// ReadInt 读取整数输入
func (ih *InputHandler) ReadInt(prompt string) (int, error) {
    fmt.Print(prompt)
    
    line, err := ih.ReadLine()
    if err != nil {
        return 0, err
    }
    
    // 清理输入
    cleaned := strings.TrimSpace(line)
    if cleaned == "" {
        return 0, fmt.Errorf("输入不能为空")
    }
    
    // 转换为整数
    num, err := strconv.Atoi(cleaned)
    if err != nil {
        return 0, fmt.Errorf("'%s' 不是有效的数字", cleaned)
    }
    
    return num, nil
}

// ReadIntInRange 读取指定范围内的整数
func (ih *InputHandler) ReadIntInRange(prompt string, min, max int) (int, error) {
    for {
        num, err := ih.ReadInt(prompt)
        if err != nil {
            return 0, err
        }
        
        if num < min || num > max {
            fmt.Printf("数字必须在 %d-%d 之间，请重新输入。\n", min, max)
            continue
        }
        
        return num, nil
    }
}
```

### 智能输入解析
```go
// parseUserInput 智能解析用户输入
func parseUserInput(input string) (int, error) {
    // 清理输入
    cleaned := strings.TrimSpace(input)
    if cleaned == "" {
        return 0, fmt.Errorf("输入不能为空")
    }
    
    // 检查是否包含非数字字符
    for _, r := range cleaned {
        if !unicode.IsDigit(r) && r != '-' && r != '+' {
            return 0, fmt.Errorf("输入包含无效字符: '%c'", r)
        }
    }
    
    // 转换为数字
    num, err := strconv.Atoi(cleaned)
    if err != nil {
        return 0, fmt.Errorf("无法解析数字: %v", err)
    }
    
    return num, nil
}

// 支持中文数字的解析（扩展功能）
func parseChineseNumber(input string) (int, error) {
    chineseNumbers := map[string]int{
        "一": 1, "二": 2, "三": 3, "四": 4, "五": 5,
        "六": 6, "七": 7, "八": 8, "九": 9, "十": 10,
        "零": 0,
    }
    
    if num, exists := chineseNumbers[input]; exists {
        return num, nil
    }
    
    return parseUserInput(input)
}
```

## 3. 错误处理策略

### 错误分类和处理
```go
// 定义错误类型
type GameError struct {
    Type    string
    Message string
    Code    int
}

func (e *GameError) Error() string {
    return fmt.Sprintf("[%s] %s (代码: %d)", e.Type, e.Message, e.Code)
}

// 错误类型常量
const (
    ErrorTypeInput      = "输入错误"
    ErrorTypeValidation = "验证错误"
    ErrorTypeSystem     = "系统错误"
)

// 创建特定类型的错误
func NewInputError(message string) *GameError {
    return &GameError{
        Type:    ErrorTypeInput,
        Message: message,
        Code:    1001,
    }
}

func NewValidationError(message string) *GameError {
    return &GameError{
        Type:    ErrorTypeValidation,
        Message: message,
        Code:    2001,
    }
}

func NewSystemError(message string) *GameError {
    return &GameError{
        Type:    ErrorTypeSystem,
        Message: message,
        Code:    3001,
    }
}
```

### 错误恢复机制
```go
// RetryableOperation 可重试的操作
type RetryableOperation func() error

// retryWithLimit 带限制的重试机制
func retryWithLimit(operation RetryableOperation, maxRetries int) error {
    var lastErr error
    
    for i := 0; i <= maxRetries; i++ {
        if err := operation(); err != nil {
            lastErr = err
            if i < maxRetries {
                fmt.Printf("操作失败，正在重试... (%d/%d)\n", i+1, maxRetries)
                continue
            }
        } else {
            return nil // 成功
        }
    }
    
    return fmt.Errorf("操作失败，已达到最大重试次数 (%d): %v", maxRetries, lastErr)
}

// 使用示例
func (g *Game) getValidInput() (int, error) {
    return retryWithLimit(func() error {
        guess, err := g.inputHandler.ReadIntInRange("请输入猜测 (1-100): ", 1, 100)
        if err != nil {
            return err
        }
        g.currentGuess = guess
        return nil
    }, 3)
}
```

## 4. 用户界面设计

### 控制台界面美化
```go
import (
    "fmt"
    "strings"
)

// UIManager 用户界面管理器
type UIManager struct {
    width int // 界面宽度
}

// NewUIManager 创建界面管理器
func NewUIManager(width int) *UIManager {
    return &UIManager{width: width}
}

// DrawBorder 绘制边框
func (ui *UIManager) DrawBorder(char string) {
    fmt.Println(strings.Repeat(char, ui.width))
}

// DrawTitle 绘制标题
func (ui *UIManager) DrawTitle(title string) {
    ui.DrawBorder("=")
    padding := (ui.width - len(title)) / 2
    fmt.Printf("%s%s%s\n", 
        strings.Repeat(" ", padding), 
        title, 
        strings.Repeat(" ", ui.width-padding-len(title)))
    ui.DrawBorder("=")
}

// DrawSection 绘制章节
func (ui *UIManager) DrawSection(title string) {
    fmt.Printf("\n%s %s %s\n", 
        strings.Repeat("-", 5), 
        title, 
        strings.Repeat("-", ui.width-len(title)-12))
}

// DrawBox 绘制信息框
func (ui *UIManager) DrawBox(content []string) {
    ui.DrawBorder("+")
    for _, line := range content {
        fmt.Printf("| %-*s |\n", ui.width-4, line)
    }
    ui.DrawBorder("+")
}

// 使用示例
func (g *Game) displayWelcomeScreen() {
    ui := NewUIManager(60)
    
    ui.DrawTitle("🎯 Go 语言猜数字游戏")
    
    ui.DrawSection("游戏规则")
    rules := []string{
        "1. 系统会随机生成一个 1-100 之间的数字",
        "2. 你需要通过猜测来找到这个数字",
        "3. 系统会提示你的猜测是太大还是太小",
        "4. 尽量用最少的次数猜中目标数字！",
    }
    ui.DrawBox(rules)
    
    ui.DrawSection("操作提示")
    tips := []string{
        "• 输入数字进行猜测",
        "• 输入 'help' 查看帮助",
        "• 输入 'quit' 退出游戏",
    }
    ui.DrawBox(tips)
    
    fmt.Println("\n按回车键开始游戏...")
    fmt.Scanln()
}
```

### 动态进度显示
```go
// ProgressBar 进度条
type ProgressBar struct {
    total   int
    current int
    width   int
}

// NewProgressBar 创建进度条
func NewProgressBar(total, width int) *ProgressBar {
    return &ProgressBar{
        total: total,
        width: width,
    }
}

// Update 更新进度
func (pb *ProgressBar) Update(current int) {
    pb.current = current
    pb.Draw()
}

// Draw 绘制进度条
func (pb *ProgressBar) Draw() {
    percentage := float64(pb.current) / float64(pb.total)
    filled := int(percentage * float64(pb.width))
    
    bar := strings.Repeat("█", filled) + strings.Repeat("░", pb.width-filled)
    fmt.Printf("\r进度: [%s] %d/%d (%.1f%%)", 
        bar, pb.current, pb.total, percentage*100)
}

// 游戏中使用进度条显示猜测次数
func (g *Game) showAttemptProgress() {
    maxAttempts := 10 // 假设最大猜测次数为10
    pb := NewProgressBar(maxAttempts, 30)
    pb.Update(g.attempts)
    fmt.Println()
}
```

## 5. 交互式帮助系统

### 帮助系统实现
```go
// HelpSystem 帮助系统
type HelpSystem struct {
    topics map[string]string
}

// NewHelpSystem 创建帮助系统
func NewHelpSystem() *HelpSystem {
    hs := &HelpSystem{
        topics: make(map[string]string),
    }
    hs.initializeTopics()
    return hs
}

// initializeTopics 初始化帮助主题
func (hs *HelpSystem) initializeTopics() {
    hs.topics["rules"] = `
游戏规则：
1. 系统随机生成一个 1-100 之间的数字
2. 你需要猜出这个数字
3. 系统会告诉你猜测是太大还是太小
4. 尽量用最少的次数猜中！
`
    
    hs.topics["commands"] = `
可用命令：
• 输入数字 (1-100) - 进行猜测
• help - 显示帮助信息
• hint - 获取提示（5次猜测后可用）
• stats - 显示当前游戏统计
• quit - 退出游戏
`
    
    hs.topics["tips"] = `
游戏技巧：
• 使用二分法：从50开始猜测
• 根据反馈缩小范围
• 记住之前的猜测结果
• 保持冷静，逻辑思考
`
}

// ShowHelp 显示帮助信息
func (hs *HelpSystem) ShowHelp(topic string) {
    if topic == "" {
        hs.showAllTopics()
        return
    }
    
    if content, exists := hs.topics[topic]; exists {
        fmt.Println(content)
    } else {
        fmt.Printf("未找到帮助主题 '%s'。可用主题：\n", topic)
        for t := range hs.topics {
            fmt.Printf("• %s\n", t)
        }
    }
}

// showAllTopics 显示所有帮助主题
func (hs *HelpSystem) showAllTopics() {
    fmt.Println("📖 游戏帮助")
    fmt.Println("可用的帮助主题：")
    for topic := range hs.topics {
        fmt.Printf("• help %s\n", topic)
    }
    fmt.Println("\n输入 'help <主题>' 查看详细信息")
}
```

## 6. 输入验证增强

### 高级验证器
```go
// Validator 验证器接口
type Validator interface {
    Validate(input string) error
}

// RangeValidator 范围验证器
type RangeValidator struct {
    Min int
    Max int
}

func (rv *RangeValidator) Validate(input string) error {
    num, err := strconv.Atoi(strings.TrimSpace(input))
    if err != nil {
        return fmt.Errorf("输入必须是数字")
    }
    
    if num < rv.Min || num > rv.Max {
        return fmt.Errorf("数字必须在 %d-%d 之间", rv.Min, rv.Max)
    }
    
    return nil
}

// LengthValidator 长度验证器
type LengthValidator struct {
    MaxLength int
}

func (lv *LengthValidator) Validate(input string) error {
    if len(input) > lv.MaxLength {
        return fmt.Errorf("输入长度不能超过 %d 个字符", lv.MaxLength)
    }
    return nil
}

// CompositeValidator 组合验证器
type CompositeValidator struct {
    validators []Validator
}

func (cv *CompositeValidator) AddValidator(v Validator) {
    cv.validators = append(cv.validators, v)
}

func (cv *CompositeValidator) Validate(input string) error {
    for _, validator := range cv.validators {
        if err := validator.Validate(input); err != nil {
            return err
        }
    }
    return nil
}

// 使用示例
func (g *Game) getValidatedInput() (int, error) {
    validator := &CompositeValidator{}
    validator.AddValidator(&LengthValidator{MaxLength: 3})
    validator.AddValidator(&RangeValidator{Min: 1, Max: 100})
    
    for {
        fmt.Print("请输入猜测 (1-100): ")
        input, err := g.inputHandler.ReadLine()
        if err != nil {
            return 0, err
        }
        
        if err := validator.Validate(input); err != nil {
            fmt.Printf("❌ %v\n", err)
            continue
        }
        
        num, _ := strconv.Atoi(strings.TrimSpace(input))
        return num, nil
    }
}
```

## 7. 错误日志记录

### 简单日志系统
```go
import (
    "log"
    "os"
    "time"
)

// Logger 日志记录器
type Logger struct {
    *log.Logger
    file *os.File
}

// NewLogger 创建日志记录器
func NewLogger(filename string) (*Logger, error) {
    file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        return nil, err
    }
    
    logger := log.New(file, "", log.LstdFlags)
    return &Logger{
        Logger: logger,
        file:   file,
    }, nil
}

// LogError 记录错误
func (l *Logger) LogError(err error) {
    l.Printf("ERROR: %v", err)
}

// LogInfo 记录信息
func (l *Logger) LogInfo(message string) {
    l.Printf("INFO: %s", message)
}

// Close 关闭日志文件
func (l *Logger) Close() error {
    return l.file.Close()
}

// 在游戏中使用日志
func (g *Game) handleError(err error) {
    if g.logger != nil {
        g.logger.LogError(err)
    }
    fmt.Printf("❌ %v\n", err)
}
```

## 8. 实践练习

### 练习1：实现命令解析器
```go
type Command struct {
    Name        string
    Description string
    Handler     func(args []string) error
}

type CommandParser struct {
    commands map[string]*Command
}

func (cp *CommandParser) AddCommand(cmd *Command) {
    cp.commands[cmd.Name] = cmd
}

func (cp *CommandParser) Parse(input string) error {
    parts := strings.Fields(input)
    if len(parts) == 0 {
        return fmt.Errorf("请输入命令")
    }
    
    cmdName := parts[0]
    args := parts[1:]
    
    if cmd, exists := cp.commands[cmdName]; exists {
        return cmd.Handler(args)
    }
    
    return fmt.Errorf("未知命令: %s", cmdName)
}
```

### 练习2：实现输入历史记录
```go
type InputHistory struct {
    history []string
    maxSize int
    current int
}

func (ih *InputHistory) Add(input string) {
    if len(ih.history) >= ih.maxSize {
        ih.history = ih.history[1:]
    }
    ih.history = append(ih.history, input)
    ih.current = len(ih.history)
}

func (ih *InputHistory) GetPrevious() string {
    if ih.current > 0 {
        ih.current--
        return ih.history[ih.current]
    }
    return ""
}
```

## 小结

本章学习了：

1. **用户交互设计**：清晰的提示、及时的反馈、良好的容错性
2. **高级输入处理**：智能解析、验证机制、错误恢复
3. **错误处理策略**：错误分类、重试机制、日志记录
4. **界面美化**：控制台界面设计、进度显示
5. **帮助系统**：交互式帮助、命令解析

良好的用户交互和错误处理是优秀软件的重要特征。

## 下一步

继续学习：[06-测试驱动开发.md](./06-测试驱动开发.md)

在下一章中，我们将学习如何编写测试来确保代码质量。
