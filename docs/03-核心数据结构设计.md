# 🏗️ 核心数据结构设计

本章将学习如何使用 Go 语言的结构体（struct）来设计猜数字游戏的核心数据结构。

## 1. 结构体基础

### 什么是结构体？
结构体是 Go 语言中用于组织相关数据的复合类型，类似于其他语言中的类（class）。

```go
// 基本结构体定义
type Person struct {
    Name string
    Age  int
}

// 创建结构体实例
var p1 Person
p1.Name = "张三"
p1.Age = 25

// 结构体字面量初始化
p2 := Person{
    Name: "李四",
    Age:  30,
}

// 简短初始化（按字段顺序）
p3 := Person{"王五", 28}
```

### 结构体指针
```go
// 创建结构体指针
p := &Person{Name: "赵六", Age: 35}

// 通过指针访问字段（Go 会自动解引用）
fmt.Println(p.Name)  // 等价于 (*p).Name

// 使用 new 创建
p2 := new(Person)
p2.Name = "钱七"
```

## 2. 游戏结构体设计

### 分析游戏需求
在设计结构体之前，我们需要分析游戏需要管理哪些数据：

1. **目标数字**：游戏生成的随机数
2. **猜测次数**：玩家已经猜测的次数
3. **输入处理器**：用于读取用户输入
4. **游戏状态**：游戏是否结束等

### Game 结构体设计
```go
package main

import (
    "bufio"
    "os"
)

// Game 结构体用于管理游戏状态
type Game struct {
    targetNumber int           // 目标数字（私有字段）
    attempts     int           // 猜测次数（私有字段）
    scanner      *bufio.Scanner // 输入扫描器（私有字段）
}
```

### 字段设计说明

1. **字段命名规范**
   - 小写字母开头：私有字段，只能在包内访问
   - 大写字母开头：公有字段，可以被其他包访问

2. **字段类型选择**
   - `targetNumber int`：整数类型，存储 1-100 的随机数
   - `attempts int`：整数类型，记录猜测次数
   - `scanner *bufio.Scanner`：指针类型，用于高效的输入处理

## 3. 构造函数设计

Go 语言没有内置的构造函数，但我们可以创建工厂函数来初始化结构体。

### NewGame 构造函数
```go
import (
    "bufio"
    "math/rand"
    "os"
    "time"
)

// NewGame 创建新游戏实例
func NewGame() *Game {
    // 设置随机数种子（确保每次运行产生不同的随机数）
    rand.Seed(time.Now().UnixNano())
    
    return &Game{
        targetNumber: rand.Intn(100) + 1, // 生成 1-100 之间的随机数
        attempts:     0,                   // 初始猜测次数为 0
        scanner:      bufio.NewScanner(os.Stdin), // 创建标准输入扫描器
    }
}
```

### 构造函数设计要点

1. **返回指针**：返回 `*Game` 而不是 `Game`，避免大结构体的值拷贝
2. **初始化所有字段**：确保结构体处于有效状态
3. **随机数种子**：使用当前时间作为种子，确保随机性
4. **资源管理**：初始化需要的外部资源（如输入扫描器）

## 4. 方法定义

### 方法 vs 函数
- **函数**：独立的代码块
- **方法**：与特定类型关联的函数

```go
// 函数
func checkGuess(target, guess int) int {
    // ...
}

// 方法
func (g *Game) checkGuess(guess int) int {
    // ...
}
```

### 接收者类型选择

#### 值接收者 vs 指针接收者
```go
// 值接收者：接收结构体的副本
func (g Game) GetAttempts() int {
    return g.attempts  // 只读操作，使用值接收者
}

// 指针接收者：接收结构体的指针
func (g *Game) IncrementAttempts() {
    g.attempts++  // 修改操作，使用指针接收者
}
```

#### 选择原则
- **使用指针接收者的情况**：
  - 需要修改结构体字段
  - 结构体较大，避免拷贝开销
  - 保持方法集的一致性

- **使用值接收者的情况**：
  - 只读操作
  - 结构体很小
  - 需要并发安全性

## 5. 核心方法实现

### checkGuess 方法
```go
// checkGuess 检查猜测结果
// 返回值：0 表示猜对，正数表示猜大了，负数表示猜小了
func (g *Game) checkGuess(guess int) int {
    if guess == g.targetNumber {
        return 0  // 猜对了
    } else if guess > g.targetNumber {
        return 1  // 猜大了
    } else {
        return -1 // 猜小了
    }
}
```

### getPlayerGuess 方法
```go
import (
    "fmt"
    "strconv"
    "strings"
)

// getPlayerGuess 获取玩家的猜测输入
func (g *Game) getPlayerGuess() (int, error) {
    fmt.Print("请输入你的猜测：")
    
    // 读取一行输入
    if !g.scanner.Scan() {
        return 0, fmt.Errorf("读取输入失败")
    }
    
    // 获取输入文本并去除首尾空格
    input := strings.TrimSpace(g.scanner.Text())
    if input == "" {
        return 0, fmt.Errorf("输入不能为空")
    }
    
    // 转换为整数
    guess, err := strconv.Atoi(input)
    if err != nil {
        return 0, fmt.Errorf("请输入一个有效的数字")
    }
    
    // 验证数字范围
    if guess < 1 || guess > 100 {
        return 0, fmt.Errorf("数字必须在 1-100 之间")
    }
    
    return guess, nil
}
```

## 6. 完整的结构体设计

```go
package main

import (
    "bufio"
    "fmt"
    "math/rand"
    "os"
    "strconv"
    "strings"
    "time"
)

// Game 结构体用于管理游戏状态
type Game struct {
    targetNumber int           // 目标数字
    attempts     int           // 猜测次数
    scanner      *bufio.Scanner // 输入扫描器
}

// NewGame 创建新游戏实例
func NewGame() *Game {
    rand.Seed(time.Now().UnixNano())
    
    return &Game{
        targetNumber: rand.Intn(100) + 1,
        attempts:     0,
        scanner:      bufio.NewScanner(os.Stdin),
    }
}

// GetAttempts 获取猜测次数（只读方法，使用值接收者）
func (g Game) GetAttempts() int {
    return g.attempts
}

// IncrementAttempts 增加猜测次数（修改方法，使用指针接收者）
func (g *Game) IncrementAttempts() {
    g.attempts++
}

// checkGuess 检查猜测结果
func (g *Game) checkGuess(guess int) int {
    if guess == g.targetNumber {
        return 0
    } else if guess > g.targetNumber {
        return 1
    } else {
        return -1
    }
}

// getPlayerGuess 获取玩家的猜测输入
func (g *Game) getPlayerGuess() (int, error) {
    fmt.Print("请输入你的猜测：")
    
    if !g.scanner.Scan() {
        return 0, fmt.Errorf("读取输入失败")
    }
    
    input := strings.TrimSpace(g.scanner.Text())
    if input == "" {
        return 0, fmt.Errorf("输入不能为空")
    }
    
    guess, err := strconv.Atoi(input)
    if err != nil {
        return 0, fmt.Errorf("请输入一个有效的数字")
    }
    
    if guess < 1 || guess > 100 {
        return 0, fmt.Errorf("数字必须在 1-100 之间")
    }
    
    return guess, nil
}
```

## 7. 设计模式应用

### 封装（Encapsulation）
```go
// 私有字段，外部无法直接访问
type Game struct {
    targetNumber int  // 小写开头，私有
    attempts     int  // 小写开头，私有
}

// 提供公有方法访问私有数据
func (g *Game) GetTargetNumber() int {
    return g.targetNumber  // 仅用于测试，实际游戏中不应暴露
}
```

### 单一职责原则
每个方法只负责一个特定的功能：
- `NewGame()`：创建游戏实例
- `checkGuess()`：检查猜测结果
- `getPlayerGuess()`：获取用户输入

## 8. 实践练习

### 练习1：扩展 Game 结构体
为游戏添加更多功能：

```go
type Game struct {
    targetNumber int
    attempts     int
    maxAttempts  int           // 最大猜测次数
    playerName   string        // 玩家姓名
    startTime    time.Time     // 游戏开始时间
    scanner      *bufio.Scanner
}

// 添加相应的方法
func (g *Game) IsGameOver() bool {
    return g.attempts >= g.maxAttempts
}

func (g *Game) GetElapsedTime() time.Duration {
    return time.Since(g.startTime)
}
```

### 练习2：创建游戏统计结构体
```go
type GameStats struct {
    TotalGames   int
    TotalWins    int
    BestAttempts int
    AverageAttempts float64
}

func (gs *GameStats) AddGame(attempts int, won bool) {
    gs.TotalGames++
    if won {
        gs.TotalWins++
        if gs.BestAttempts == 0 || attempts < gs.BestAttempts {
            gs.BestAttempts = attempts
        }
    }
    // 计算平均猜测次数的逻辑...
}
```

## 小结

本章学习了：

1. **结构体基础**：定义、初始化和使用
2. **游戏结构体设计**：分析需求，设计合理的数据结构
3. **构造函数模式**：使用工厂函数初始化结构体
4. **方法定义**：值接收者 vs 指针接收者的选择
5. **封装原则**：通过私有字段和公有方法实现数据封装

良好的数据结构设计是程序成功的基础，它能让代码更加清晰、可维护和可扩展。

## 下一步

继续学习：[04-游戏逻辑实现.md](./04-游戏逻辑实现.md)

在下一章中，我们将实现完整的游戏逻辑，包括游戏主循环和核心算法。
