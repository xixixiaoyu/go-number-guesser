# ğŸ§ª æµ‹è¯•é©±åŠ¨å¼€å‘

æœ¬ç« å°†å­¦ä¹ å¦‚ä½•ä¸ºçŒœæ•°å­—æ¸¸æˆç¼–å†™å…¨é¢çš„æµ‹è¯•ï¼ŒåŒ…æ‹¬å•å…ƒæµ‹è¯•ã€åŸºå‡†æµ‹è¯•å’Œæµ‹è¯•è¦†ç›–ç‡åˆ†æã€‚

## 1. Go è¯­è¨€æµ‹è¯•åŸºç¡€

### æµ‹è¯•æ–‡ä»¶å‘½åè§„èŒƒ
```go
// ä¸»æ–‡ä»¶: main.go
// æµ‹è¯•æ–‡ä»¶: main_test.go

// åŒ…åå¿…é¡»ä¸è¢«æµ‹è¯•çš„åŒ…ç›¸åŒ
package main

import (
    "testing"
)
```

### æµ‹è¯•å‡½æ•°å‘½åè§„èŒƒ
```go
// å•å…ƒæµ‹è¯•å‡½æ•°å¿…é¡»ä»¥ Test å¼€å¤´
func TestNewGame(t *testing.T) {
    // æµ‹è¯•ä»£ç 
}

// åŸºå‡†æµ‹è¯•å‡½æ•°å¿…é¡»ä»¥ Benchmark å¼€å¤´
func BenchmarkNewGame(b *testing.B) {
    // åŸºå‡†æµ‹è¯•ä»£ç 
}

// ç¤ºä¾‹å‡½æ•°å¿…é¡»ä»¥ Example å¼€å¤´
func ExampleNewGame() {
    // ç¤ºä¾‹ä»£ç 
}
```

## 2. å•å…ƒæµ‹è¯•ç¼–å†™

### åŸºæœ¬æµ‹è¯•ç»“æ„
```go
func TestNewGame(t *testing.T) {
    // Arrange (å‡†å¤‡)
    // è®¾ç½®æµ‹è¯•æ•°æ®å’Œç¯å¢ƒ
    
    // Act (æ‰§è¡Œ)
    game := NewGame()
    
    // Assert (æ–­è¨€)
    if game == nil {
        t.Fatal("NewGame() è¿”å›äº† nil")
    }
    
    if game.targetNumber < 1 || game.targetNumber > 100 {
        t.Errorf("ç›®æ ‡æ•°å­— %d ä¸åœ¨ 1-100 èŒƒå›´å†…", game.targetNumber)
    }
    
    if game.attempts != 0 {
        t.Errorf("åˆå§‹çŒœæµ‹æ¬¡æ•°åº”è¯¥ä¸º 0ï¼Œå®é™…ä¸º %d", game.attempts)
    }
}
```

### æµ‹è¯•æ–­è¨€æ–¹æ³•
```go
// t.Error vs t.Fatal
func TestExample(t *testing.T) {
    // t.Error: è®°å½•é”™è¯¯ä½†ç»§ç»­æ‰§è¡Œ
    if condition1 {
        t.Error("æ¡ä»¶1å¤±è´¥")
    }
    
    // t.Errorf: æ ¼å¼åŒ–é”™è¯¯ä¿¡æ¯
    if condition2 {
        t.Errorf("æœŸæœ›å€¼ %dï¼Œå®é™…å€¼ %d", expected, actual)
    }
    
    // t.Fatal: è®°å½•é”™è¯¯å¹¶ç«‹å³åœæ­¢æµ‹è¯•
    if criticalCondition {
        t.Fatal("å…³é”®æ¡ä»¶å¤±è´¥ï¼Œåœæ­¢æµ‹è¯•")
    }
    
    // t.Fatalf: æ ¼å¼åŒ–è‡´å‘½é”™è¯¯
    if anotherCriticalCondition {
        t.Fatalf("å…³é”®é”™è¯¯ï¼š%v", err)
    }
}
```

## 3. æ¸¸æˆé€»è¾‘æµ‹è¯•

### æµ‹è¯• checkGuess æ–¹æ³•
```go
func TestCheckGuess(t *testing.T) {
    // åˆ›å»ºæµ‹è¯•ç”¨çš„æ¸¸æˆå®ä¾‹
    game := &Game{targetNumber: 50, attempts: 0}
    
    // æµ‹è¯•ç”¨ä¾‹ç»“æ„
    testCases := []struct {
        name     string
        guess    int
        expected int
    }{
        {"çŒœå¯¹äº†", 50, 0},
        {"çŒœå¤§äº†", 75, 1},
        {"çŒœå°äº†", 25, -1},
        {"è¾¹ç•Œå€¼-æœ€å°", 1, -1},
        {"è¾¹ç•Œå€¼-æœ€å¤§", 100, 1},
    }
    
    // æ‰§è¡Œæµ‹è¯•ç”¨ä¾‹
    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            result := game.checkGuess(tc.guess)
            if result != tc.expected {
                t.Errorf("çŒœæµ‹ %d æ—¶ï¼ŒæœŸæœ›è¿”å› %dï¼Œå®é™…è¿”å› %d", 
                    tc.guess, tc.expected, result)
            }
        })
    }
}
```

### æµ‹è¯•éšæœºæ•°ç”Ÿæˆ
```go
func TestRandomness(t *testing.T) {
    // æµ‹è¯•éšæœºæ•°çš„å¤šæ ·æ€§
    numbers := make(map[int]bool)
    iterations := 100
    
    for i := 0; i < iterations; i++ {
        game := NewGame()
        numbers[game.targetNumber] = true
    }
    
    // æ£€æŸ¥éšæœºæ•°çš„å¤šæ ·æ€§
    uniqueCount := len(numbers)
    minExpected := 50 // æœŸæœ›è‡³å°‘æœ‰50ä¸ªä¸åŒçš„æ•°å­—
    
    if uniqueCount < minExpected {
        t.Errorf("éšæœºæ•°å¤šæ ·æ€§ä¸è¶³ï¼š%dæ¬¡ç”Ÿæˆåªæœ‰ %d ä¸ªä¸åŒæ•°å­—ï¼ŒæœŸæœ›è‡³å°‘ %d ä¸ª", 
            iterations, uniqueCount, minExpected)
    }
    
    // æ£€æŸ¥æ‰€æœ‰æ•°å­—éƒ½åœ¨æœ‰æ•ˆèŒƒå›´å†…
    for num := range numbers {
        if num < 1 || num > 100 {
            t.Errorf("ç”Ÿæˆçš„éšæœºæ•° %d è¶…å‡ºæœ‰æ•ˆèŒƒå›´ 1-100", num)
        }
    }
}
```

### æµ‹è¯•è¾¹ç•Œæ¡ä»¶
```go
func TestBoundaryConditions(t *testing.T) {
    game := &Game{targetNumber: 50}
    
    // æµ‹è¯•è¾¹ç•Œå€¼
    boundaryTests := []struct {
        guess    int
        expected int
        desc     string
    }{
        {1, -1, "æœ€å°å€¼"},
        {100, 1, "æœ€å¤§å€¼"},
        {49, -1, "ç›®æ ‡å€¼-1"},
        {51, 1, "ç›®æ ‡å€¼+1"},
        {50, 0, "ç›®æ ‡å€¼"},
    }
    
    for _, test := range boundaryTests {
        t.Run(test.desc, func(t *testing.T) {
            result := game.checkGuess(test.guess)
            if result != test.expected {
                t.Errorf("%s: çŒœæµ‹ %dï¼ŒæœŸæœ› %dï¼Œå¾—åˆ° %d", 
                    test.desc, test.guess, test.expected, result)
            }
        })
    }
}
```

## 4. é”™è¯¯å¤„ç†æµ‹è¯•

### æµ‹è¯•è¾“å…¥éªŒè¯
```go
func TestInputValidation(t *testing.T) {
    // æ¨¡æ‹Ÿä¸åŒçš„è¾“å…¥æƒ…å†µ
    testCases := []struct {
        input       string
        shouldError bool
        description string
    }{
        {"50", false, "æœ‰æ•ˆè¾“å…¥"},
        {"", true, "ç©ºè¾“å…¥"},
        {"abc", true, "éæ•°å­—è¾“å…¥"},
        {"0", true, "å°äºæœ€å°å€¼"},
        {"101", true, "å¤§äºæœ€å¤§å€¼"},
        {"-5", true, "è´Ÿæ•°"},
        {"50.5", true, "å°æ•°"},
        {"  25  ", false, "å¸¦ç©ºæ ¼çš„æœ‰æ•ˆè¾“å…¥"},
    }
    
    for _, tc := range testCases {
        t.Run(tc.description, func(t *testing.T) {
            _, err := validateInput(tc.input)
            
            if tc.shouldError && err == nil {
                t.Errorf("è¾“å…¥ '%s' åº”è¯¥äº§ç”Ÿé”™è¯¯ï¼Œä½†æ²¡æœ‰", tc.input)
            }
            
            if !tc.shouldError && err != nil {
                t.Errorf("è¾“å…¥ '%s' ä¸åº”è¯¥äº§ç”Ÿé”™è¯¯ï¼Œä½†å¾—åˆ°: %v", tc.input, err)
            }
        })
    }
}

// è¾…åŠ©å‡½æ•°ï¼šéªŒè¯è¾“å…¥
func validateInput(input string) (int, error) {
    input = strings.TrimSpace(input)
    if input == "" {
        return 0, fmt.Errorf("è¾“å…¥ä¸èƒ½ä¸ºç©º")
    }
    
    num, err := strconv.Atoi(input)
    if err != nil {
        return 0, fmt.Errorf("è¾“å…¥ä¸æ˜¯æœ‰æ•ˆæ•°å­—")
    }
    
    if num < 1 || num > 100 {
        return 0, fmt.Errorf("æ•°å­—å¿…é¡»åœ¨ 1-100 ä¹‹é—´")
    }
    
    return num, nil
}
```

## 5. æ¨¡æ‹Ÿå’Œä¾èµ–æ³¨å…¥

### æ¥å£è®¾è®¡ç”¨äºæµ‹è¯•
```go
// å®šä¹‰æ¥å£ä»¥ä¾¿äºæµ‹è¯•
type RandomGenerator interface {
    Intn(n int) int
}

type RealRandomGenerator struct{}

func (r *RealRandomGenerator) Intn(n int) int {
    return rand.Intn(n)
}

// å¯æµ‹è¯•çš„æ¸¸æˆç»“æ„
type TestableGame struct {
    targetNumber int
    attempts     int
    rng          RandomGenerator
}

// æ„é€ å‡½æ•°æ”¯æŒä¾èµ–æ³¨å…¥
func NewTestableGame(rng RandomGenerator) *TestableGame {
    return &TestableGame{
        targetNumber: rng.Intn(100) + 1,
        attempts:     0,
        rng:          rng,
    }
}
```

### æ¨¡æ‹Ÿéšæœºæ•°ç”Ÿæˆå™¨
```go
// æ¨¡æ‹Ÿéšæœºæ•°ç”Ÿæˆå™¨
type MockRandomGenerator struct {
    values []int
    index  int
}

func (m *MockRandomGenerator) Intn(n int) int {
    if m.index >= len(m.values) {
        return 0
    }
    value := m.values[m.index]
    m.index++
    return value
}

// ä½¿ç”¨æ¨¡æ‹Ÿå™¨è¿›è¡Œæµ‹è¯•
func TestGameWithMockRandom(t *testing.T) {
    // åˆ›å»ºæ¨¡æ‹Ÿéšæœºæ•°ç”Ÿæˆå™¨
    mockRng := &MockRandomGenerator{values: []int{49}} // ç”Ÿæˆæ•°å­—50
    
    // åˆ›å»ºå¯æµ‹è¯•çš„æ¸¸æˆ
    game := NewTestableGame(mockRng)
    
    // éªŒè¯ç›®æ ‡æ•°å­—
    if game.targetNumber != 50 {
        t.Errorf("æœŸæœ›ç›®æ ‡æ•°å­—ä¸º 50ï¼Œå®é™…ä¸º %d", game.targetNumber)
    }
    
    // æµ‹è¯•çŒœæµ‹é€»è¾‘
    result := game.checkGuess(50)
    if result != 0 {
        t.Errorf("çŒœæµ‹50åº”è¯¥æ­£ç¡®ï¼Œä½†è¿”å› %d", result)
    }
}
```

## 6. åŸºå‡†æµ‹è¯•

### æ€§èƒ½åŸºå‡†æµ‹è¯•
```go
// æµ‹è¯•æ¸¸æˆåˆ›å»ºæ€§èƒ½
func BenchmarkNewGame(b *testing.B) {
    for i := 0; i < b.N; i++ {
        NewGame()
    }
}

// æµ‹è¯•çŒœæµ‹æ£€æŸ¥æ€§èƒ½
func BenchmarkCheckGuess(b *testing.B) {
    game := &Game{targetNumber: 50}
    
    b.ResetTimer() // é‡ç½®è®¡æ—¶å™¨ï¼Œæ’é™¤å‡†å¤‡æ—¶é—´
    for i := 0; i < b.N; i++ {
        game.checkGuess(25)
    }
}

// æµ‹è¯•ä¸åŒè¾“å…¥çš„æ€§èƒ½
func BenchmarkInputValidation(b *testing.B) {
    inputs := []string{"50", "abc", "101", "", "  25  "}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        input := inputs[i%len(inputs)]
        validateInput(input)
    }
}
```

### å†…å­˜åˆ†é…åŸºå‡†æµ‹è¯•
```go
func BenchmarkGameMemoryAllocation(b *testing.B) {
    b.ReportAllocs() // æŠ¥å‘Šå†…å­˜åˆ†é…æƒ…å†µ
    
    for i := 0; i < b.N; i++ {
        game := NewGame()
        _ = game.checkGuess(50)
    }
}
```

## 7. æµ‹è¯•è¦†ç›–ç‡

### è¿è¡Œæµ‹è¯•å’Œè¦†ç›–ç‡åˆ†æ
```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
go test -v

# è¿è¡ŒåŸºå‡†æµ‹è¯•
go test -bench=.

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
go test -cover

# ç”Ÿæˆè¯¦ç»†çš„è¦†ç›–ç‡æŠ¥å‘Š
go test -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html

# æŸ¥çœ‹è¦†ç›–ç‡è¯¦æƒ…
go tool cover -func=coverage.out
```

### æé«˜æµ‹è¯•è¦†ç›–ç‡
```go
// æµ‹è¯•æ‰€æœ‰ä»£ç è·¯å¾„
func TestAllCodePaths(t *testing.T) {
    // æµ‹è¯•æˆåŠŸè·¯å¾„
    t.Run("æˆåŠŸè·¯å¾„", func(t *testing.T) {
        game := &Game{targetNumber: 50}
        result := game.checkGuess(50)
        if result != 0 {
            t.Error("æˆåŠŸè·¯å¾„æµ‹è¯•å¤±è´¥")
        }
    })
    
    // æµ‹è¯•é”™è¯¯è·¯å¾„
    t.Run("é”™è¯¯è·¯å¾„", func(t *testing.T) {
        _, err := validateInput("abc")
        if err == nil {
            t.Error("é”™è¯¯è·¯å¾„æµ‹è¯•å¤±è´¥")
        }
    })
    
    // æµ‹è¯•è¾¹ç•Œæ¡ä»¶
    t.Run("è¾¹ç•Œæ¡ä»¶", func(t *testing.T) {
        game := &Game{targetNumber: 1}
        result := game.checkGuess(1)
        if result != 0 {
            t.Error("è¾¹ç•Œæ¡ä»¶æµ‹è¯•å¤±è´¥")
        }
    })
}
```

## 8. é›†æˆæµ‹è¯•

### ç«¯åˆ°ç«¯æµ‹è¯•
```go
func TestGameIntegration(t *testing.T) {
    // åˆ›å»ºæ¸¸æˆ
    game := NewGame()
    
    // æ¨¡æ‹Ÿå®Œæ•´çš„æ¸¸æˆæµç¨‹
    maxAttempts := 20
    found := false
    
    for i := 1; i <= 100 && game.attempts < maxAttempts; i++ {
        result := game.checkGuess(i)
        game.attempts++
        
        if result == 0 {
            found = true
            break
        }
    }
    
    if !found {
        t.Errorf("åœ¨ %d æ¬¡å°è¯•å†…æœªèƒ½æ‰¾åˆ°ç›®æ ‡æ•°å­—", maxAttempts)
    }
    
    if game.attempts == 0 {
        t.Error("çŒœæµ‹æ¬¡æ•°åº”è¯¥å¤§äº0")
    }
}
```

## 9. æµ‹è¯•å·¥å…·å’Œæœ€ä½³å®è·µ

### æµ‹è¯•è¾…åŠ©å‡½æ•°
```go
// æ–­è¨€è¾…åŠ©å‡½æ•°
func assertEqual(t *testing.T, expected, actual interface{}) {
    t.Helper() // æ ‡è®°ä¸ºè¾…åŠ©å‡½æ•°
    if expected != actual {
        t.Errorf("æœŸæœ› %vï¼Œå®é™… %v", expected, actual)
    }
}

func assertNotNil(t *testing.T, value interface{}) {
    t.Helper()
    if value == nil {
        t.Error("å€¼ä¸åº”è¯¥ä¸º nil")
    }
}

func assertError(t *testing.T, err error, shouldHaveError bool) {
    t.Helper()
    if shouldHaveError && err == nil {
        t.Error("æœŸæœ›æœ‰é”™è¯¯ï¼Œä½†æ²¡æœ‰")
    }
    if !shouldHaveError && err != nil {
        t.Errorf("ä¸æœŸæœ›æœ‰é”™è¯¯ï¼Œä½†å¾—åˆ°: %v", err)
    }
}

// ä½¿ç”¨è¾…åŠ©å‡½æ•°
func TestWithHelpers(t *testing.T) {
    game := NewGame()
    
    assertNotNil(t, game)
    assertEqual(t, 0, game.attempts)
    
    result := game.checkGuess(50)
    // result åº”è¯¥æ˜¯ -1, 0, æˆ– 1
    if result < -1 || result > 1 {
        t.Errorf("checkGuess è¿”å›å€¼è¶…å‡ºé¢„æœŸèŒƒå›´: %d", result)
    }
}
```

### è¡¨é©±åŠ¨æµ‹è¯•
```go
func TestTableDriven(t *testing.T) {
    tests := []struct {
        name         string
        targetNumber int
        guess        int
        expected     int
    }{
        {"çŒœå¯¹", 50, 50, 0},
        {"çŒœå¤§", 50, 75, 1},
        {"çŒœå°", 50, 25, -1},
        {"è¾¹ç•Œæœ€å°", 1, 1, 0},
        {"è¾¹ç•Œæœ€å¤§", 100, 100, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            game := &Game{targetNumber: tt.targetNumber}
            result := game.checkGuess(tt.guess)
            assertEqual(t, tt.expected, result)
        })
    }
}
```

## 10. å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šä¸ºæ–°åŠŸèƒ½ç¼–å†™æµ‹è¯•
```go
// ä¸ºæ¸¸æˆæ·»åŠ æç¤ºåŠŸèƒ½
func (g *Game) GetHint() string {
    if g.targetNumber%2 == 0 {
        return "ç›®æ ‡æ•°å­—æ˜¯å¶æ•°"
    }
    return "ç›®æ ‡æ•°å­—æ˜¯å¥‡æ•°"
}

// ç¼–å†™å¯¹åº”çš„æµ‹è¯•
func TestGetHint(t *testing.T) {
    tests := []struct {
        targetNumber int
        expected     string
    }{
        {50, "ç›®æ ‡æ•°å­—æ˜¯å¶æ•°"},
        {51, "ç›®æ ‡æ•°å­—æ˜¯å¥‡æ•°"},
        {2, "ç›®æ ‡æ•°å­—æ˜¯å¶æ•°"},
        {1, "ç›®æ ‡æ•°å­—æ˜¯å¥‡æ•°"},
    }
    
    for _, tt := range tests {
        t.Run(fmt.Sprintf("ç›®æ ‡æ•°å­—%d", tt.targetNumber), func(t *testing.T) {
            game := &Game{targetNumber: tt.targetNumber}
            hint := game.GetHint()
            assertEqual(t, tt.expected, hint)
        })
    }
}
```

### ç»ƒä¹ 2ï¼šæ€§èƒ½ä¼˜åŒ–æµ‹è¯•
```go
func BenchmarkGamePerformance(b *testing.B) {
    b.Run("åˆ›å»ºæ¸¸æˆ", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            NewGame()
        }
    })
    
    b.Run("çŒœæµ‹æ£€æŸ¥", func(b *testing.B) {
        game := NewGame()
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            game.checkGuess(50)
        }
    })
}
```

## å°ç»“

æœ¬ç« å­¦ä¹ äº†ï¼š

1. **æµ‹è¯•åŸºç¡€**ï¼šæµ‹è¯•æ–‡ä»¶ç»“æ„ã€å‘½åè§„èŒƒã€åŸºæœ¬æ–­è¨€
2. **å•å…ƒæµ‹è¯•**ï¼šé€»è¾‘æµ‹è¯•ã€è¾¹ç•Œæ¡ä»¶æµ‹è¯•ã€é”™è¯¯å¤„ç†æµ‹è¯•
3. **æ¨¡æ‹Ÿå’Œä¾èµ–æ³¨å…¥**ï¼šæ¥å£è®¾è®¡ã€æ¨¡æ‹Ÿå¯¹è±¡ã€å¯æµ‹è¯•æ€§
4. **åŸºå‡†æµ‹è¯•**ï¼šæ€§èƒ½æµ‹è¯•ã€å†…å­˜åˆ†é…åˆ†æ
5. **æµ‹è¯•è¦†ç›–ç‡**ï¼šè¦†ç›–ç‡åˆ†æã€æé«˜è¦†ç›–ç‡ç­–ç•¥
6. **æµ‹è¯•æœ€ä½³å®è·µ**ï¼šè¾…åŠ©å‡½æ•°ã€è¡¨é©±åŠ¨æµ‹è¯•ã€é›†æˆæµ‹è¯•

è‰¯å¥½çš„æµ‹è¯•æ˜¯é«˜è´¨é‡è½¯ä»¶çš„ä¿è¯ï¼Œæµ‹è¯•é©±åŠ¨å¼€å‘èƒ½å¸®åŠ©æˆ‘ä»¬å†™å‡ºæ›´å¥½çš„ä»£ç ã€‚

## ä¸‹ä¸€æ­¥

ç»§ç»­å­¦ä¹ ï¼š[07-é¡¹ç›®ä¼˜åŒ–ä¸æ‰©å±•.md](./07-é¡¹ç›®ä¼˜åŒ–ä¸æ‰©å±•.md)

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•ä¼˜åŒ–é¡¹ç›®æ€§èƒ½å’Œæ‰©å±•åŠŸèƒ½ã€‚
