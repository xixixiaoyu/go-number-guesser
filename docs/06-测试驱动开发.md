# 🧪 测试驱动开发

本章将学习如何为猜数字游戏编写全面的测试，包括单元测试、基准测试和测试覆盖率分析。

## 1. Go 语言测试基础

### 测试文件命名规范
```go
// 主文件: main.go
// 测试文件: main_test.go

// 包名必须与被测试的包相同
package main

import (
    "testing"
)
```

### 测试函数命名规范
```go
// 单元测试函数必须以 Test 开头
func TestNewGame(t *testing.T) {
    // 测试代码
}

// 基准测试函数必须以 Benchmark 开头
func BenchmarkNewGame(b *testing.B) {
    // 基准测试代码
}

// 示例函数必须以 Example 开头
func ExampleNewGame() {
    // 示例代码
}
```

## 2. 单元测试编写

### 基本测试结构
```go
func TestNewGame(t *testing.T) {
    // Arrange (准备)
    // 设置测试数据和环境
    
    // Act (执行)
    game := NewGame()
    
    // Assert (断言)
    if game == nil {
        t.Fatal("NewGame() 返回了 nil")
    }
    
    if game.targetNumber < 1 || game.targetNumber > 100 {
        t.Errorf("目标数字 %d 不在 1-100 范围内", game.targetNumber)
    }
    
    if game.attempts != 0 {
        t.Errorf("初始猜测次数应该为 0，实际为 %d", game.attempts)
    }
}
```

### 测试断言方法
```go
// t.Error vs t.Fatal
func TestExample(t *testing.T) {
    // t.Error: 记录错误但继续执行
    if condition1 {
        t.Error("条件1失败")
    }
    
    // t.Errorf: 格式化错误信息
    if condition2 {
        t.Errorf("期望值 %d，实际值 %d", expected, actual)
    }
    
    // t.Fatal: 记录错误并立即停止测试
    if criticalCondition {
        t.Fatal("关键条件失败，停止测试")
    }
    
    // t.Fatalf: 格式化致命错误
    if anotherCriticalCondition {
        t.Fatalf("关键错误：%v", err)
    }
}
```

## 3. 游戏逻辑测试

### 测试 checkGuess 方法
```go
func TestCheckGuess(t *testing.T) {
    // 创建测试用的游戏实例
    game := &Game{targetNumber: 50, attempts: 0}
    
    // 测试用例结构
    testCases := []struct {
        name     string
        guess    int
        expected int
    }{
        {"猜对了", 50, 0},
        {"猜大了", 75, 1},
        {"猜小了", 25, -1},
        {"边界值-最小", 1, -1},
        {"边界值-最大", 100, 1},
    }
    
    // 执行测试用例
    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            result := game.checkGuess(tc.guess)
            if result != tc.expected {
                t.Errorf("猜测 %d 时，期望返回 %d，实际返回 %d", 
                    tc.guess, tc.expected, result)
            }
        })
    }
}
```

### 测试随机数生成
```go
func TestRandomness(t *testing.T) {
    // 测试随机数的多样性
    numbers := make(map[int]bool)
    iterations := 100
    
    for i := 0; i < iterations; i++ {
        game := NewGame()
        numbers[game.targetNumber] = true
    }
    
    // 检查随机数的多样性
    uniqueCount := len(numbers)
    minExpected := 50 // 期望至少有50个不同的数字
    
    if uniqueCount < minExpected {
        t.Errorf("随机数多样性不足：%d次生成只有 %d 个不同数字，期望至少 %d 个", 
            iterations, uniqueCount, minExpected)
    }
    
    // 检查所有数字都在有效范围内
    for num := range numbers {
        if num < 1 || num > 100 {
            t.Errorf("生成的随机数 %d 超出有效范围 1-100", num)
        }
    }
}
```

### 测试边界条件
```go
func TestBoundaryConditions(t *testing.T) {
    game := &Game{targetNumber: 50}
    
    // 测试边界值
    boundaryTests := []struct {
        guess    int
        expected int
        desc     string
    }{
        {1, -1, "最小值"},
        {100, 1, "最大值"},
        {49, -1, "目标值-1"},
        {51, 1, "目标值+1"},
        {50, 0, "目标值"},
    }
    
    for _, test := range boundaryTests {
        t.Run(test.desc, func(t *testing.T) {
            result := game.checkGuess(test.guess)
            if result != test.expected {
                t.Errorf("%s: 猜测 %d，期望 %d，得到 %d", 
                    test.desc, test.guess, test.expected, result)
            }
        })
    }
}
```

## 4. 错误处理测试

### 测试输入验证
```go
func TestInputValidation(t *testing.T) {
    // 模拟不同的输入情况
    testCases := []struct {
        input       string
        shouldError bool
        description string
    }{
        {"50", false, "有效输入"},
        {"", true, "空输入"},
        {"abc", true, "非数字输入"},
        {"0", true, "小于最小值"},
        {"101", true, "大于最大值"},
        {"-5", true, "负数"},
        {"50.5", true, "小数"},
        {"  25  ", false, "带空格的有效输入"},
    }
    
    for _, tc := range testCases {
        t.Run(tc.description, func(t *testing.T) {
            _, err := validateInput(tc.input)
            
            if tc.shouldError && err == nil {
                t.Errorf("输入 '%s' 应该产生错误，但没有", tc.input)
            }
            
            if !tc.shouldError && err != nil {
                t.Errorf("输入 '%s' 不应该产生错误，但得到: %v", tc.input, err)
            }
        })
    }
}

// 辅助函数：验证输入
func validateInput(input string) (int, error) {
    input = strings.TrimSpace(input)
    if input == "" {
        return 0, fmt.Errorf("输入不能为空")
    }
    
    num, err := strconv.Atoi(input)
    if err != nil {
        return 0, fmt.Errorf("输入不是有效数字")
    }
    
    if num < 1 || num > 100 {
        return 0, fmt.Errorf("数字必须在 1-100 之间")
    }
    
    return num, nil
}
```

## 5. 模拟和依赖注入

### 接口设计用于测试
```go
// 定义接口以便于测试
type RandomGenerator interface {
    Intn(n int) int
}

type RealRandomGenerator struct{}

func (r *RealRandomGenerator) Intn(n int) int {
    return rand.Intn(n)
}

// 可测试的游戏结构
type TestableGame struct {
    targetNumber int
    attempts     int
    rng          RandomGenerator
}

// 构造函数支持依赖注入
func NewTestableGame(rng RandomGenerator) *TestableGame {
    return &TestableGame{
        targetNumber: rng.Intn(100) + 1,
        attempts:     0,
        rng:          rng,
    }
}
```

### 模拟随机数生成器
```go
// 模拟随机数生成器
type MockRandomGenerator struct {
    values []int
    index  int
}

func (m *MockRandomGenerator) Intn(n int) int {
    if m.index >= len(m.values) {
        return 0
    }
    value := m.values[m.index]
    m.index++
    return value
}

// 使用模拟器进行测试
func TestGameWithMockRandom(t *testing.T) {
    // 创建模拟随机数生成器
    mockRng := &MockRandomGenerator{values: []int{49}} // 生成数字50
    
    // 创建可测试的游戏
    game := NewTestableGame(mockRng)
    
    // 验证目标数字
    if game.targetNumber != 50 {
        t.Errorf("期望目标数字为 50，实际为 %d", game.targetNumber)
    }
    
    // 测试猜测逻辑
    result := game.checkGuess(50)
    if result != 0 {
        t.Errorf("猜测50应该正确，但返回 %d", result)
    }
}
```

## 6. 基准测试

### 性能基准测试
```go
// 测试游戏创建性能
func BenchmarkNewGame(b *testing.B) {
    for i := 0; i < b.N; i++ {
        NewGame()
    }
}

// 测试猜测检查性能
func BenchmarkCheckGuess(b *testing.B) {
    game := &Game{targetNumber: 50}
    
    b.ResetTimer() // 重置计时器，排除准备时间
    for i := 0; i < b.N; i++ {
        game.checkGuess(25)
    }
}

// 测试不同输入的性能
func BenchmarkInputValidation(b *testing.B) {
    inputs := []string{"50", "abc", "101", "", "  25  "}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        input := inputs[i%len(inputs)]
        validateInput(input)
    }
}
```

### 内存分配基准测试
```go
func BenchmarkGameMemoryAllocation(b *testing.B) {
    b.ReportAllocs() // 报告内存分配情况
    
    for i := 0; i < b.N; i++ {
        game := NewGame()
        _ = game.checkGuess(50)
    }
}
```

## 7. 测试覆盖率

### 运行测试和覆盖率分析
```bash
# 运行所有测试
go test -v

# 运行基准测试
go test -bench=.

# 生成覆盖率报告
go test -cover

# 生成详细的覆盖率报告
go test -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html

# 查看覆盖率详情
go tool cover -func=coverage.out
```

### 提高测试覆盖率
```go
// 测试所有代码路径
func TestAllCodePaths(t *testing.T) {
    // 测试成功路径
    t.Run("成功路径", func(t *testing.T) {
        game := &Game{targetNumber: 50}
        result := game.checkGuess(50)
        if result != 0 {
            t.Error("成功路径测试失败")
        }
    })
    
    // 测试错误路径
    t.Run("错误路径", func(t *testing.T) {
        _, err := validateInput("abc")
        if err == nil {
            t.Error("错误路径测试失败")
        }
    })
    
    // 测试边界条件
    t.Run("边界条件", func(t *testing.T) {
        game := &Game{targetNumber: 1}
        result := game.checkGuess(1)
        if result != 0 {
            t.Error("边界条件测试失败")
        }
    })
}
```

## 8. 集成测试

### 端到端测试
```go
func TestGameIntegration(t *testing.T) {
    // 创建游戏
    game := NewGame()
    
    // 模拟完整的游戏流程
    maxAttempts := 20
    found := false
    
    for i := 1; i <= 100 && game.attempts < maxAttempts; i++ {
        result := game.checkGuess(i)
        game.attempts++
        
        if result == 0 {
            found = true
            break
        }
    }
    
    if !found {
        t.Errorf("在 %d 次尝试内未能找到目标数字", maxAttempts)
    }
    
    if game.attempts == 0 {
        t.Error("猜测次数应该大于0")
    }
}
```

## 9. 测试工具和最佳实践

### 测试辅助函数
```go
// 断言辅助函数
func assertEqual(t *testing.T, expected, actual interface{}) {
    t.Helper() // 标记为辅助函数
    if expected != actual {
        t.Errorf("期望 %v，实际 %v", expected, actual)
    }
}

func assertNotNil(t *testing.T, value interface{}) {
    t.Helper()
    if value == nil {
        t.Error("值不应该为 nil")
    }
}

func assertError(t *testing.T, err error, shouldHaveError bool) {
    t.Helper()
    if shouldHaveError && err == nil {
        t.Error("期望有错误，但没有")
    }
    if !shouldHaveError && err != nil {
        t.Errorf("不期望有错误，但得到: %v", err)
    }
}

// 使用辅助函数
func TestWithHelpers(t *testing.T) {
    game := NewGame()
    
    assertNotNil(t, game)
    assertEqual(t, 0, game.attempts)
    
    result := game.checkGuess(50)
    // result 应该是 -1, 0, 或 1
    if result < -1 || result > 1 {
        t.Errorf("checkGuess 返回值超出预期范围: %d", result)
    }
}
```

### 表驱动测试
```go
func TestTableDriven(t *testing.T) {
    tests := []struct {
        name         string
        targetNumber int
        guess        int
        expected     int
    }{
        {"猜对", 50, 50, 0},
        {"猜大", 50, 75, 1},
        {"猜小", 50, 25, -1},
        {"边界最小", 1, 1, 0},
        {"边界最大", 100, 100, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            game := &Game{targetNumber: tt.targetNumber}
            result := game.checkGuess(tt.guess)
            assertEqual(t, tt.expected, result)
        })
    }
}
```

## 10. 实践练习

### 练习1：为新功能编写测试
```go
// 为游戏添加提示功能
func (g *Game) GetHint() string {
    if g.targetNumber%2 == 0 {
        return "目标数字是偶数"
    }
    return "目标数字是奇数"
}

// 编写对应的测试
func TestGetHint(t *testing.T) {
    tests := []struct {
        targetNumber int
        expected     string
    }{
        {50, "目标数字是偶数"},
        {51, "目标数字是奇数"},
        {2, "目标数字是偶数"},
        {1, "目标数字是奇数"},
    }
    
    for _, tt := range tests {
        t.Run(fmt.Sprintf("目标数字%d", tt.targetNumber), func(t *testing.T) {
            game := &Game{targetNumber: tt.targetNumber}
            hint := game.GetHint()
            assertEqual(t, tt.expected, hint)
        })
    }
}
```

### 练习2：性能优化测试
```go
func BenchmarkGamePerformance(b *testing.B) {
    b.Run("创建游戏", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            NewGame()
        }
    })
    
    b.Run("猜测检查", func(b *testing.B) {
        game := NewGame()
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            game.checkGuess(50)
        }
    })
}
```

## 小结

本章学习了：

1. **测试基础**：测试文件结构、命名规范、基本断言
2. **单元测试**：逻辑测试、边界条件测试、错误处理测试
3. **模拟和依赖注入**：接口设计、模拟对象、可测试性
4. **基准测试**：性能测试、内存分配分析
5. **测试覆盖率**：覆盖率分析、提高覆盖率策略
6. **测试最佳实践**：辅助函数、表驱动测试、集成测试

良好的测试是高质量软件的保证，测试驱动开发能帮助我们写出更好的代码。

## 下一步

继续学习：[07-项目优化与扩展.md](./07-项目优化与扩展.md)

在下一章中，我们将学习如何优化项目性能和扩展功能。
