# 第三章：核心设计

## 🏗️ 架构设计思路

在开始编码之前，我们需要仔细设计程序的架构。好的设计能让代码更清晰、更易维护、更容易测试。

### 设计原则

1. **单一职责原则**：每个函数和结构体只负责一个明确的功能
2. **开闭原则**：对扩展开放，对修改封闭
3. **依赖倒置**：依赖抽象而不是具体实现
4. **简单性原则**：保持代码简单易懂

### 模块划分

```
┌─────────────────────────────────────┐
│              main 函数              │
│         (程序入口和流程控制)         │
└─────────────┬───────────────────────┘
              │
┌─────────────▼───────────────────────┐
│             Game 结构体             │
│         (游戏状态和核心逻辑)         │
├─────────────────────────────────────┤
│  • targetNumber (目标数字)          │
│  • attempts (猜测次数)              │
│  • scanner (输入扫描器)             │
├─────────────────────────────────────┤
│  • NewGame() (创建游戏)             │
│  • Start() (开始游戏)               │
│  • getPlayerGuess() (获取输入)      │
│  • checkGuess() (检查猜测)          │
└─────────────────────────────────────┘
```

## 📊 数据结构设计

### Game 结构体

这是我们程序的核心数据结构，用于管理游戏状态：

```go
type Game struct {
    targetNumber int           // 目标数字 (1-100)
    attempts     int           // 当前游戏的猜测次数
    scanner      *bufio.Scanner // 用于读取用户输入
}
```

#### 字段说明

1. **targetNumber**
   - 类型：`int`
   - 作用：存储本轮游戏的目标数字
   - 范围：1-100
   - 生成时机：创建新游戏时

2. **attempts**
   - 类型：`int`
   - 作用：记录玩家在当前游戏中的猜测次数
   - 初始值：0
   - 更新时机：每次玩家进行有效猜测时 +1

3. **scanner**
   - 类型：`*bufio.Scanner`
   - 作用：提供缓冲的输入读取功能
   - 优势：比直接使用 `fmt.Scan` 更安全，能更好地处理输入错误

### 为什么使用结构体？

1. **数据封装**：将相关的数据组织在一起
2. **状态管理**：每个游戏实例都有独立的状态
3. **方法绑定**：可以为结构体定义方法
4. **扩展性**：未来可以轻松添加新字段

## 🔧 方法设计

### 构造函数：NewGame()

```go
func NewGame() *Game
```

**职责**：
- 创建新的游戏实例
- 初始化随机数种子
- 生成目标数字
- 设置初始状态

**设计考虑**：
- 返回指针而不是值，避免大结构体的复制
- 每次调用都生成新的随机数
- 确保随机数的质量

### 游戏主循环：Start()

```go
func (g *Game) Start()
```

**职责**：
- 显示欢迎信息
- 管理游戏主循环
- 处理游戏结束逻辑

**流程设计**：
```
显示欢迎信息
    ↓
开始循环
    ↓
获取用户输入 ← (错误处理)
    ↓
增加猜测次数
    ↓
检查猜测结果
    ↓
显示反馈信息
    ↓
猜对了？ ──否──┘
    ↓ 是
显示成功信息
    ↓
结束游戏
```

### 输入处理：getPlayerGuess()

```go
func (g *Game) getPlayerGuess() (int, error)
```

**职责**：
- 提示用户输入
- 读取并验证输入
- 返回有效数字或错误

**验证规则**：
1. 输入不能为空
2. 必须是有效数字
3. 数字必须在 1-100 范围内

**错误处理策略**：
- 使用 Go 的错误返回模式
- 提供具体的错误信息
- 不会导致程序崩溃

### 逻辑判断：checkGuess()

```go
func (g *Game) checkGuess(guess int) int
```

**职责**：
- 比较猜测数字与目标数字
- 返回比较结果

**返回值设计**：
- `0`：猜对了
- `正数`：猜大了
- `负数`：猜小了

**优势**：
- 简单直观的返回值
- 易于测试
- 逻辑清晰

## 🎮 游戏流程设计

### 主程序流程

```go
func main() {
    显示标题
    for {
        创建新游戏
        开始游戏
        if !询问是否继续() {
            break
        }
    }
    显示结束信息
}
```

### 单轮游戏流程

```go
func (g *Game) Start() {
    显示欢迎信息
    for {
        获取用户输入
        if 输入有错误 {
            显示错误信息
            continue
        }
        
        增加猜测次数
        检查猜测结果
        
        if 猜对了 {
            显示成功信息
            break
        } else {
            显示提示信息
        }
    }
}
```

## 🛡️ 错误处理设计

### Go 语言错误处理模式

Go 语言使用显式的错误处理，而不是异常机制：

```go
result, err := someFunction()
if err != nil {
    // 处理错误
    return err
}
// 使用 result
```

### 我们的错误处理策略

1. **输入验证错误**：
   ```go
   guess, err := g.getPlayerGuess()
   if err != nil {
       fmt.Printf("输入错误：%v，请重新输入。\n", err)
       continue // 不退出游戏，让用户重新输入
   }
   ```

2. **系统级错误**：
   ```go
   if !g.scanner.Scan() {
       return 0, fmt.Errorf("读取输入失败")
   }
   ```

3. **业务逻辑错误**：
   ```go
   if guess < 1 || guess > 100 {
       return 0, fmt.Errorf("数字必须在 1-100 之间")
   }
   ```

### 错误信息设计原则

1. **用户友好**：使用中文，描述清晰
2. **具体明确**：指出具体的问题
3. **指导性**：告诉用户如何修正
4. **一致性**：错误格式保持一致

## 🎨 用户界面设计

### 界面元素

1. **标题栏**：
   ```
   ==================================================
   🎯 Go 语言猜数字游戏
   ==================================================
   ```

2. **游戏提示**：
   ```
   欢迎来到猜数字游戏！
   我已经想好了一个 1-100 之间的数字，请开始猜测：
   ```

3. **输入提示**：
   ```
   请输入你的猜测：
   ```

4. **反馈信息**：
   ```
   太大了！请再试一次。
   太小了！请再试一次。
   恭喜你！猜对了！你总共猜了 X 次。
   ```

5. **继续询问**：
   ```
   是否继续游戏？(y/n)：
   ```

### 视觉设计考虑

1. **分隔线**：使用 `=` 字符创建视觉分隔
2. **表情符号**：增加趣味性（🎯、👋）
3. **空行**：适当的空白增加可读性
4. **对齐**：保持界面整洁

## 🧪 可测试性设计

### 测试友好的设计

1. **纯函数**：`checkGuess()` 是纯函数，易于测试
2. **状态隔离**：每个 `Game` 实例独立
3. **依赖注入**：可以为测试注入 mock 对象
4. **小函数**：每个函数职责单一，易于测试

### 测试策略

1. **单元测试**：测试每个方法的功能
2. **边界测试**：测试边界条件
3. **错误测试**：测试错误处理逻辑
4. **随机性测试**：验证随机数生成的质量

## 📈 扩展性考虑

### 未来可能的扩展

1. **难度级别**：
   ```go
   type Game struct {
       targetNumber int
       attempts     int
       scanner      *bufio.Scanner
       minRange     int  // 新增：最小范围
       maxRange     int  // 新增：最大范围
   }
   ```

2. **游戏统计**：
   ```go
   type GameStats struct {
       totalGames    int
       totalAttempts int
       bestScore     int
   }
   ```

3. **多人模式**：
   ```go
   type Player struct {
       name     string
       attempts int
   }
   ```

### 设计模式应用

1. **工厂模式**：`NewGame()` 函数
2. **状态模式**：游戏状态管理
3. **策略模式**：不同难度级别的实现

## 🎯 设计总结

我们的设计具有以下优点：

1. **简洁性**：结构清晰，易于理解
2. **可维护性**：职责分离，修改影响小
3. **可测试性**：函数独立，易于测试
4. **可扩展性**：预留扩展空间
5. **健壮性**：完善的错误处理

## 🚀 下一步

在下一章中，我们将开始实现这个设计：
- 创建 `Game` 结构体
- 实现 `NewGame()` 构造函数
- 编写基本的游戏逻辑
- 添加随机数生成功能

设计阶段完成，让我们开始编码吧！
