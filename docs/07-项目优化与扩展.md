# ğŸš€ é¡¹ç›®ä¼˜åŒ–ä¸æ‰©å±•

æœ¬ç« å°†å­¦ä¹ å¦‚ä½•ä¼˜åŒ–çŒœæ•°å­—æ¸¸æˆçš„æ€§èƒ½ï¼Œå¹¶æ‰©å±•æ›´å¤šæœ‰è¶£çš„åŠŸèƒ½ã€‚

## 1. æ€§èƒ½ä¼˜åŒ–

### å†…å­˜ä¼˜åŒ–
```go
// ä¼˜åŒ–å‰ï¼šæ¯æ¬¡éƒ½åˆ›å»ºæ–°çš„ Scanner
func (g *Game) getPlayerGuess() (int, error) {
    scanner := bufio.NewScanner(os.Stdin) // æ¯æ¬¡éƒ½åˆ›å»ºæ–°å®ä¾‹
    // ...
}

// ä¼˜åŒ–åï¼šå¤ç”¨ Scanner
type Game struct {
    targetNumber int
    attempts     int
    scanner      *bufio.Scanner // å¤ç”¨å®ä¾‹
}

func NewGame() *Game {
    return &Game{
        targetNumber: rand.Intn(100) + 1,
        attempts:     0,
        scanner:      bufio.NewScanner(os.Stdin), // åªåˆ›å»ºä¸€æ¬¡
    }
}
```

### å­—ç¬¦ä¸²æ“ä½œä¼˜åŒ–
```go
import (
    "strings"
    "bytes"
)

// ä¼˜åŒ–å‰ï¼šé¢‘ç¹çš„å­—ç¬¦ä¸²æ‹¼æ¥
func createBorder(width int) string {
    result := ""
    for i := 0; i < width; i++ {
        result += "="  // æ¯æ¬¡æ‹¼æ¥éƒ½ä¼šåˆ›å»ºæ–°å­—ç¬¦ä¸²
    }
    return result
}

// ä¼˜åŒ–åï¼šä½¿ç”¨ strings.Repeat
func createBorderOptimized(width int) string {
    return strings.Repeat("=", width)
}

// æˆ–è€…ä½¿ç”¨ bytes.Buffer è¿›è¡Œå¤æ‚æ‹¼æ¥
func createComplexString(parts []string) string {
    var buffer bytes.Buffer
    for _, part := range parts {
        buffer.WriteString(part)
    }
    return buffer.String()
}
```

### éšæœºæ•°ç”Ÿæˆä¼˜åŒ–
```go
import (
    "math/rand"
    "sync"
    "time"
)

// çº¿ç¨‹å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆå™¨
type SafeRandom struct {
    rng *rand.Rand
    mu  sync.Mutex
}

func NewSafeRandom() *SafeRandom {
    return &SafeRandom{
        rng: rand.New(rand.NewSource(time.Now().UnixNano())),
    }
}

func (sr *SafeRandom) Intn(n int) int {
    sr.mu.Lock()
    defer sr.mu.Unlock()
    return sr.rng.Intn(n)
}

// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘å†…å­˜åˆ†é…
var gamePool = sync.Pool{
    New: func() interface{} {
        return &Game{}
    },
}

func NewGameFromPool() *Game {
    game := gamePool.Get().(*Game)
    game.reset()
    return game
}

func (g *Game) reset() {
    g.targetNumber = rand.Intn(100) + 1
    g.attempts = 0
}

func (g *Game) Release() {
    gamePool.Put(g)
}
```

## 2. åŠŸèƒ½æ‰©å±•

### éš¾åº¦çº§åˆ«ç³»ç»Ÿ
```go
type Difficulty int

const (
    Easy Difficulty = iota
    Medium
    Hard
    Expert
)

type DifficultyConfig struct {
    Name      string
    MinNumber int
    MaxNumber int
    MaxHints  int
}

var difficultyConfigs = map[Difficulty]DifficultyConfig{
    Easy:   {"ç®€å•", 1, 50, 3},
    Medium: {"ä¸­ç­‰", 1, 100, 2},
    Hard:   {"å›°éš¾", 1, 200, 1},
    Expert: {"ä¸“å®¶", 1, 500, 0},
}

type EnhancedGame struct {
    targetNumber int
    attempts     int
    difficulty   Difficulty
    hintsUsed    int
    scanner      *bufio.Scanner
}

func NewEnhancedGame(diff Difficulty) *EnhancedGame {
    config := difficultyConfigs[diff]
    rand.Seed(time.Now().UnixNano())
    
    return &EnhancedGame{
        targetNumber: rand.Intn(config.MaxNumber-config.MinNumber+1) + config.MinNumber,
        attempts:     0,
        difficulty:   diff,
        hintsUsed:    0,
        scanner:      bufio.NewScanner(os.Stdin),
    }
}

func (g *EnhancedGame) GetHint() string {
    config := difficultyConfigs[g.difficulty]
    if g.hintsUsed >= config.MaxHints {
        return "å·²è¾¾åˆ°æœ€å¤§æç¤ºæ¬¡æ•°"
    }
    
    g.hintsUsed++
    
    // æ ¹æ®å·²ä½¿ç”¨çš„æç¤ºæ¬¡æ•°æä¾›ä¸åŒçº§åˆ«çš„æç¤º
    switch g.hintsUsed {
    case 1:
        if g.targetNumber%2 == 0 {
            return "ğŸ’¡ æç¤º1ï¼šç›®æ ‡æ•°å­—æ˜¯å¶æ•°"
        }
        return "ğŸ’¡ æç¤º1ï¼šç›®æ ‡æ•°å­—æ˜¯å¥‡æ•°"
    case 2:
        if g.targetNumber <= (config.MaxNumber-config.MinNumber)/2+config.MinNumber {
            return "ğŸ’¡ æç¤º2ï¼šç›®æ ‡æ•°å­—åœ¨è¾ƒå°çš„ä¸€åŠèŒƒå›´å†…"
        }
        return "ğŸ’¡ æç¤º2ï¼šç›®æ ‡æ•°å­—åœ¨è¾ƒå¤§çš„ä¸€åŠèŒƒå›´å†…"
    case 3:
        return fmt.Sprintf("ğŸ’¡ æç¤º3ï¼šç›®æ ‡æ•°å­—çš„åä½æ•°æ˜¯ %d", g.targetNumber/10)
    default:
        return "æ²¡æœ‰æ›´å¤šæç¤ºäº†"
    }
}
```

### æ¸¸æˆç»Ÿè®¡ç³»ç»Ÿ
```go
import (
    "encoding/json"
    "os"
    "time"
)

type GameStats struct {
    TotalGames      int                    `json:"total_games"`
    TotalWins       int                    `json:"total_wins"`
    TotalAttempts   int                    `json:"total_attempts"`
    BestScore       int                    `json:"best_score"`
    AverageAttempts float64               `json:"average_attempts"`
    DifficultyStats map[Difficulty]DifficultyStats `json:"difficulty_stats"`
    LastPlayed      time.Time             `json:"last_played"`
}

type DifficultyStats struct {
    Games    int     `json:"games"`
    Wins     int     `json:"wins"`
    BestScore int    `json:"best_score"`
    WinRate  float64 `json:"win_rate"`
}

func NewGameStats() *GameStats {
    return &GameStats{
        DifficultyStats: make(map[Difficulty]DifficultyStats),
    }
}

func (gs *GameStats) AddGame(difficulty Difficulty, attempts int, won bool) {
    gs.TotalGames++
    gs.TotalAttempts += attempts
    gs.LastPlayed = time.Now()
    
    if won {
        gs.TotalWins++
        if gs.BestScore == 0 || attempts < gs.BestScore {
            gs.BestScore = attempts
        }
    }
    
    // æ›´æ–°å¹³å‡çŒœæµ‹æ¬¡æ•°
    gs.AverageAttempts = float64(gs.TotalAttempts) / float64(gs.TotalGames)
    
    // æ›´æ–°éš¾åº¦ç»Ÿè®¡
    diffStats := gs.DifficultyStats[difficulty]
    diffStats.Games++
    if won {
        diffStats.Wins++
        if diffStats.BestScore == 0 || attempts < diffStats.BestScore {
            diffStats.BestScore = attempts
        }
    }
    diffStats.WinRate = float64(diffStats.Wins) / float64(diffStats.Games)
    gs.DifficultyStats[difficulty] = diffStats
}

func (gs *GameStats) SaveToFile(filename string) error {
    data, err := json.MarshalIndent(gs, "", "  ")
    if err != nil {
        return err
    }
    return os.WriteFile(filename, data, 0644)
}

func LoadGameStats(filename string) (*GameStats, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        if os.IsNotExist(err) {
            return NewGameStats(), nil
        }
        return nil, err
    }
    
    var stats GameStats
    err = json.Unmarshal(data, &stats)
    if err != nil {
        return nil, err
    }
    
    if stats.DifficultyStats == nil {
        stats.DifficultyStats = make(map[Difficulty]DifficultyStats)
    }
    
    return &stats, nil
}

func (gs *GameStats) DisplayStats() {
    fmt.Println("\nğŸ“Š æ¸¸æˆç»Ÿè®¡")
    fmt.Println(strings.Repeat("=", 40))
    fmt.Printf("æ€»æ¸¸æˆæ¬¡æ•°: %d\n", gs.TotalGames)
    fmt.Printf("è·èƒœæ¬¡æ•°: %d\n", gs.TotalWins)
    fmt.Printf("èƒœç‡: %.1f%%\n", float64(gs.TotalWins)/float64(gs.TotalGames)*100)
    fmt.Printf("æœ€ä½³æˆç»©: %d æ¬¡\n", gs.BestScore)
    fmt.Printf("å¹³å‡çŒœæµ‹æ¬¡æ•°: %.1f\n", gs.AverageAttempts)
    fmt.Printf("ä¸Šæ¬¡æ¸¸æˆ: %s\n", gs.LastPlayed.Format("2006-01-02 15:04:05"))

    fmt.Println("\nå„éš¾åº¦ç»Ÿè®¡:")
    for diff, stats := range gs.DifficultyStats {
        config := difficultyConfigs[diff]
        fmt.Printf("  %s: %då±€ èƒœç‡%.1f%% æœ€ä½³%dæ¬¡\n",
            config.Name, stats.Games, stats.WinRate*100, stats.BestScore)
    }
}

### æˆå°±ç³»ç»Ÿ
```go
type Achievement struct {
    ID          string `json:"id"`
    Name        string `json:"name"`
    Description string `json:"description"`
    Unlocked    bool   `json:"unlocked"`
    UnlockedAt  time.Time `json:"unlocked_at"`
}

type AchievementManager struct {
    achievements map[string]*Achievement
    stats        *GameStats
}

func NewAchievementManager(stats *GameStats) *AchievementManager {
    am := &AchievementManager{
        achievements: make(map[string]*Achievement),
        stats:        stats,
    }
    am.initializeAchievements()
    return am
}

func (am *AchievementManager) initializeAchievements() {
    achievements := []*Achievement{
        {"first_win", "åˆæ¬¡èƒœåˆ©", "èµ¢å¾—ç¬¬ä¸€åœºæ¸¸æˆ", false, time.Time{}},
        {"quick_win", "ç¥é€ŸçŒœä¸­", "åœ¨3æ¬¡å†…çŒœä¸­æ•°å­—", false, time.Time{}},
        {"persistent", "åšæŒä¸æ‡ˆ", "å®Œæˆ10åœºæ¸¸æˆ", false, time.Time{}},
        {"master", "çŒœæ•°å¤§å¸ˆ", "åœ¨å›°éš¾æ¨¡å¼ä¸‹è·èƒœ", false, time.Time{}},
        {"perfect", "å®Œç¾è¡¨ç°", "è¿ç»­5åœºæ¸¸æˆè·èƒœ", false, time.Time{}},
    }

    for _, achievement := range achievements {
        am.achievements[achievement.ID] = achievement
    }
}

func (am *AchievementManager) CheckAchievements(difficulty Difficulty, attempts int, won bool) []string {
    var newAchievements []string

    // æ£€æŸ¥å„ç§æˆå°±æ¡ä»¶
    if won && !am.achievements["first_win"].Unlocked && am.stats.TotalWins == 1 {
        am.unlockAchievement("first_win")
        newAchievements = append(newAchievements, "first_win")
    }

    if won && attempts <= 3 && !am.achievements["quick_win"].Unlocked {
        am.unlockAchievement("quick_win")
        newAchievements = append(newAchievements, "quick_win")
    }

    if am.stats.TotalGames >= 10 && !am.achievements["persistent"].Unlocked {
        am.unlockAchievement("persistent")
        newAchievements = append(newAchievements, "persistent")
    }

    if won && difficulty == Hard && !am.achievements["master"].Unlocked {
        am.unlockAchievement("master")
        newAchievements = append(newAchievements, "master")
    }

    return newAchievements
}

func (am *AchievementManager) unlockAchievement(id string) {
    if achievement, exists := am.achievements[id]; exists {
        achievement.Unlocked = true
        achievement.UnlockedAt = time.Now()
    }
}

func (am *AchievementManager) DisplayAchievements() {
    fmt.Println("\nğŸ† æˆå°±ç³»ç»Ÿ")
    fmt.Println(strings.Repeat("=", 40))

    for _, achievement := range am.achievements {
        status := "ğŸ”’"
        timeStr := ""
        if achievement.Unlocked {
            status = "âœ…"
            timeStr = fmt.Sprintf(" (%s)", achievement.UnlockedAt.Format("2006-01-02"))
        }

        fmt.Printf("%s %s: %s%s\n",
            status, achievement.Name, achievement.Description, timeStr)
    }
}

## 3. é…ç½®ç³»ç»Ÿ

### é…ç½®æ–‡ä»¶ç®¡ç†
```go
import (
    "encoding/json"
    "os"
)

type GameConfig struct {
    DefaultDifficulty Difficulty `json:"default_difficulty"`
    AutoSave         bool       `json:"auto_save"`
    SoundEnabled     bool       `json:"sound_enabled"`
    Language         string     `json:"language"`
    Theme            string     `json:"theme"`
    MaxAttempts      int        `json:"max_attempts"`
}

func DefaultConfig() *GameConfig {
    return &GameConfig{
        DefaultDifficulty: Medium,
        AutoSave:         true,
        SoundEnabled:     false,
        Language:         "zh-CN",
        Theme:            "default",
        MaxAttempts:      0, // 0 è¡¨ç¤ºæ— é™åˆ¶
    }
}

func LoadConfig(filename string) (*GameConfig, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        if os.IsNotExist(err) {
            return DefaultConfig(), nil
        }
        return nil, err
    }

    var config GameConfig
    err = json.Unmarshal(data, &config)
    if err != nil {
        return nil, err
    }

    return &config, nil
}

func (gc *GameConfig) SaveToFile(filename string) error {
    data, err := json.MarshalIndent(gc, "", "  ")
    if err != nil {
        return err
    }
    return os.WriteFile(filename, data, 0644)
}

## 4. å¤šè¯­è¨€æ”¯æŒ

### å›½é™…åŒ–ç³»ç»Ÿ
```go
type Localizer struct {
    language string
    messages map[string]map[string]string
}

func NewLocalizer(language string) *Localizer {
    l := &Localizer{
        language: language,
        messages: make(map[string]map[string]string),
    }
    l.loadMessages()
    return l
}

func (l *Localizer) loadMessages() {
    // ä¸­æ–‡æ¶ˆæ¯
    l.messages["zh-CN"] = map[string]string{
        "welcome":           "æ¬¢è¿æ¥åˆ°çŒœæ•°å­—æ¸¸æˆï¼",
        "game_start":        "æˆ‘å·²ç»æƒ³å¥½äº†ä¸€ä¸ª %d-%d ä¹‹é—´çš„æ•°å­—ï¼Œè¯·å¼€å§‹çŒœæµ‹ï¼š",
        "input_prompt":      "è¯·è¾“å…¥ä½ çš„çŒœæµ‹ï¼š",
        "too_high":          "å¤ªå¤§äº†ï¼è¯·å†è¯•ä¸€æ¬¡ã€‚",
        "too_low":           "å¤ªå°äº†ï¼è¯·å†è¯•ä¸€æ¬¡ã€‚",
        "correct":           "æ­å–œä½ ï¼çŒœå¯¹äº†ï¼ä½ æ€»å…±çŒœäº† %d æ¬¡ã€‚",
        "continue_game":     "æ˜¯å¦ç»§ç»­æ¸¸æˆï¼Ÿ(y/n)ï¼š",
        "goodbye":           "æ„Ÿè°¢æ¸¸æˆï¼å†è§ï¼ğŸ‘‹",
        "invalid_input":     "è¾“å…¥é”™è¯¯ï¼š%vï¼Œè¯·é‡æ–°è¾“å…¥ã€‚",
        "new_game":          "å¼€å§‹æ–°æ¸¸æˆï¼",
    }

    // è‹±æ–‡æ¶ˆæ¯
    l.messages["en-US"] = map[string]string{
        "welcome":           "Welcome to the Number Guessing Game!",
        "game_start":        "I'm thinking of a number between %d and %d. Start guessing:",
        "input_prompt":      "Enter your guess: ",
        "too_high":          "Too high! Try again.",
        "too_low":           "Too low! Try again.",
        "correct":           "Congratulations! You got it in %d attempts!",
        "continue_game":     "Continue playing? (y/n): ",
        "goodbye":           "Thanks for playing! Goodbye! ğŸ‘‹",
        "invalid_input":     "Input error: %v, please try again.",
        "new_game":          "Starting new game!",
    }
}

func (l *Localizer) Get(key string, args ...interface{}) string {
    if langMessages, exists := l.messages[l.language]; exists {
        if message, exists := langMessages[key]; exists {
            if len(args) > 0 {
                return fmt.Sprintf(message, args...)
            }
            return message
        }
    }

    // å›é€€åˆ°è‹±æ–‡
    if langMessages, exists := l.messages["en-US"]; exists {
        if message, exists := langMessages[key]; exists {
            if len(args) > 0 {
                return fmt.Sprintf(message, args...)
            }
            return message
        }
    }

    return key // å¦‚æœéƒ½æ‰¾ä¸åˆ°ï¼Œè¿”å›é”®å
}

## 5. å‘½ä»¤è¡Œç•Œé¢å¢å¼º

### å½©è‰²è¾“å‡º
```go
import (
    "fmt"
)

// ANSI é¢œè‰²ä»£ç 
const (
    ColorReset  = "\033[0m"
    ColorRed    = "\033[31m"
    ColorGreen  = "\033[32m"
    ColorYellow = "\033[33m"
    ColorBlue   = "\033[34m"
    ColorPurple = "\033[35m"
    ColorCyan   = "\033[36m"
    ColorWhite  = "\033[37m"
)

type ColorPrinter struct {
    enabled bool
}

func NewColorPrinter(enabled bool) *ColorPrinter {
    return &ColorPrinter{enabled: enabled}
}

func (cp *ColorPrinter) Printf(color, format string, args ...interface{}) {
    if cp.enabled {
        fmt.Printf(color+format+ColorReset, args...)
    } else {
        fmt.Printf(format, args...)
    }
}

func (cp *ColorPrinter) Success(format string, args ...interface{}) {
    cp.Printf(ColorGreen, format, args...)
}

func (cp *ColorPrinter) Error(format string, args ...interface{}) {
    cp.Printf(ColorRed, format, args...)
}

func (cp *ColorPrinter) Warning(format string, args ...interface{}) {
    cp.Printf(ColorYellow, format, args...)
}

func (cp *ColorPrinter) Info(format string, args ...interface{}) {
    cp.Printf(ColorBlue, format, args...)
}

### è¿›åº¦æ¡å’ŒåŠ¨ç”»
```go
import (
    "time"
)

type Spinner struct {
    chars []string
    delay time.Duration
}

func NewSpinner() *Spinner {
    return &Spinner{
        chars: []string{"|", "/", "-", "\\"},
        delay: 100 * time.Millisecond,
    }
}

func (s *Spinner) Start(message string) chan bool {
    stop := make(chan bool)

    go func() {
        i := 0
        for {
            select {
            case <-stop:
                fmt.Print("\r" + strings.Repeat(" ", len(message)+5) + "\r")
                return
            default:
                fmt.Printf("\r%s %s", s.chars[i%len(s.chars)], message)
                i++
                time.Sleep(s.delay)
            }
        }
    }()

    return stop
}

// ä½¿ç”¨ç¤ºä¾‹
func loadGameWithSpinner() {
    spinner := NewSpinner()
    stop := spinner.Start("æ­£åœ¨åŠ è½½æ¸¸æˆ...")

    // æ¨¡æ‹ŸåŠ è½½è¿‡ç¨‹
    time.Sleep(2 * time.Second)

    stop <- true
    fmt.Println("æ¸¸æˆåŠ è½½å®Œæˆï¼")
}

## 6. ä»£ç é‡æ„å’Œæ¶æ„ä¼˜åŒ–

### æ¥å£åˆ†ç¦»
```go
// æ¸¸æˆæ ¸å¿ƒæ¥å£
type GameEngine interface {
    Start()
    CheckGuess(guess int) int
    IsGameOver() bool
    GetAttempts() int
}

// ç”¨æˆ·äº¤äº’æ¥å£
type UserInterface interface {
    GetInput() (int, error)
    ShowMessage(message string)
    ShowError(err error)
    ShowStats(stats *GameStats)
}

// æ•°æ®æŒä¹…åŒ–æ¥å£
type DataPersistence interface {
    SaveStats(stats *GameStats) error
    LoadStats() (*GameStats, error)
    SaveConfig(config *GameConfig) error
    LoadConfig() (*GameConfig, error)
}

// å…·ä½“å®ç°
type ConsoleUI struct {
    scanner *bufio.Scanner
    printer *ColorPrinter
    localizer *Localizer
}

func NewConsoleUI(printer *ColorPrinter, localizer *Localizer) *ConsoleUI {
    return &ConsoleUI{
        scanner:   bufio.NewScanner(os.Stdin),
        printer:   printer,
        localizer: localizer,
    }
}

func (cui *ConsoleUI) GetInput() (int, error) {
    cui.printer.Info(cui.localizer.Get("input_prompt"))

    if !cui.scanner.Scan() {
        return 0, fmt.Errorf("è¯»å–è¾“å…¥å¤±è´¥")
    }

    input := strings.TrimSpace(cui.scanner.Text())
    if input == "" {
        return 0, fmt.Errorf("è¾“å…¥ä¸èƒ½ä¸ºç©º")
    }

    guess, err := strconv.Atoi(input)
    if err != nil {
        return 0, fmt.Errorf("è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„æ•°å­—")
    }

    return guess, nil
}

func (cui *ConsoleUI) ShowMessage(message string) {
    cui.printer.Info("%s\n", message)
}

func (cui *ConsoleUI) ShowError(err error) {
    cui.printer.Error("âŒ %v\n", err)
}

### ä¾èµ–æ³¨å…¥å®¹å™¨
```go
type Container struct {
    services map[string]interface{}
}

func NewContainer() *Container {
    return &Container{
        services: make(map[string]interface{}),
    }
}

func (c *Container) Register(name string, service interface{}) {
    c.services[name] = service
}

func (c *Container) Get(name string) interface{} {
    return c.services[name]
}

func (c *Container) GetGameEngine() GameEngine {
    return c.Get("game_engine").(GameEngine)
}

func (c *Container) GetUserInterface() UserInterface {
    return c.Get("user_interface").(UserInterface)
}

func (c *Container) GetDataPersistence() DataPersistence {
    return c.Get("data_persistence").(DataPersistence)
}

// åº”ç”¨ç¨‹åºå¯åŠ¨å™¨
type Application struct {
    container *Container
}

func NewApplication() *Application {
    app := &Application{
        container: NewContainer(),
    }
    app.setupDependencies()
    return app
}

func (app *Application) setupDependencies() {
    // é…ç½®æœåŠ¡
    config := DefaultConfig()
    app.container.Register("config", config)

    // æœ¬åœ°åŒ–æœåŠ¡
    localizer := NewLocalizer(config.Language)
    app.container.Register("localizer", localizer)

    // é¢œè‰²æ‰“å°æœåŠ¡
    printer := NewColorPrinter(true)
    app.container.Register("printer", printer)

    // ç”¨æˆ·ç•Œé¢æœåŠ¡
    ui := NewConsoleUI(printer, localizer)
    app.container.Register("user_interface", ui)

    // æ¸¸æˆå¼•æ“æœåŠ¡
    game := NewEnhancedGame(config.DefaultDifficulty)
    app.container.Register("game_engine", game)

    // æ•°æ®æŒä¹…åŒ–æœåŠ¡
    persistence := NewFilePersistence("game_data.json", "game_config.json")
    app.container.Register("data_persistence", persistence)
}

func (app *Application) Run() {
    ui := app.container.GetUserInterface()
    engine := app.container.GetGameEngine()

    ui.ShowMessage("æ¬¢è¿æ¥åˆ°çŒœæ•°å­—æ¸¸æˆï¼")

    for {
        engine.Start()

        // è¯¢é—®æ˜¯å¦ç»§ç»­...
        // æ¸¸æˆä¸»å¾ªç¯é€»è¾‘
    }
}

## 7. å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šå®ç°æ’è¡Œæ¦œç³»ç»Ÿ
```go
type LeaderboardEntry struct {
    PlayerName string    `json:"player_name"`
    Score      int       `json:"score"`
    Difficulty Difficulty `json:"difficulty"`
    Date       time.Time `json:"date"`
}

type Leaderboard struct {
    entries []LeaderboardEntry
    maxSize int
}

func NewLeaderboard(maxSize int) *Leaderboard {
    return &Leaderboard{
        entries: make([]LeaderboardEntry, 0),
        maxSize: maxSize,
    }
}

func (lb *Leaderboard) AddEntry(entry LeaderboardEntry) {
    lb.entries = append(lb.entries, entry)

    // æŒ‰åˆ†æ•°æ’åºï¼ˆåˆ†æ•°è¶Šä½è¶Šå¥½ï¼‰
    sort.Slice(lb.entries, func(i, j int) bool {
        return lb.entries[i].Score < lb.entries[j].Score
    })

    // ä¿æŒæœ€å¤§æ¡ç›®æ•°
    if len(lb.entries) > lb.maxSize {
        lb.entries = lb.entries[:lb.maxSize]
    }
}

func (lb *Leaderboard) Display() {
    fmt.Println("\nğŸ† æ’è¡Œæ¦œ")
    fmt.Println(strings.Repeat("=", 50))

    for i, entry := range lb.entries {
        rank := i + 1
        diffName := difficultyConfigs[entry.Difficulty].Name
        fmt.Printf("%d. %s - %dæ¬¡ (%s) %s\n",
            rank, entry.PlayerName, entry.Score, diffName,
            entry.Date.Format("2006-01-02"))
    }
}
```

### ç»ƒä¹ 2ï¼šå®ç°æ¸¸æˆå›æ”¾ç³»ç»Ÿ
```go
type GameMove struct {
    Guess     int       `json:"guess"`
    Result    int       `json:"result"`
    Timestamp time.Time `json:"timestamp"`
}

type GameReplay struct {
    GameID       string     `json:"game_id"`
    TargetNumber int        `json:"target_number"`
    Difficulty   Difficulty `json:"difficulty"`
    Moves        []GameMove `json:"moves"`
    StartTime    time.Time  `json:"start_time"`
    EndTime      time.Time  `json:"end_time"`
    Won          bool       `json:"won"`
}

func (gr *GameReplay) AddMove(guess, result int) {
    move := GameMove{
        Guess:     guess,
        Result:    result,
        Timestamp: time.Now(),
    }
    gr.Moves = append(gr.Moves, move)
}

func (gr *GameReplay) PlayReplay() {
    fmt.Printf("å›æ”¾æ¸¸æˆ %s\n", gr.GameID)
    fmt.Printf("ç›®æ ‡æ•°å­—: %d, éš¾åº¦: %s\n",
        gr.TargetNumber, difficultyConfigs[gr.Difficulty].Name)

    for i, move := range gr.Moves {
        fmt.Printf("ç¬¬%dæ¬¡çŒœæµ‹: %d -> ", i+1, move.Guess)
        switch move.Result {
        case 0:
            fmt.Println("çŒœå¯¹äº†ï¼")
        case 1:
            fmt.Println("å¤ªå¤§äº†")
        case -1:
            fmt.Println("å¤ªå°äº†")
        }
        time.Sleep(500 * time.Millisecond) // æ¨¡æ‹Ÿå›æ”¾é€Ÿåº¦
    }
}
```

## å°ç»“

æœ¬ç« å­¦ä¹ äº†ï¼š

1. **æ€§èƒ½ä¼˜åŒ–**ï¼šå†…å­˜ä¼˜åŒ–ã€å­—ç¬¦ä¸²æ“ä½œä¼˜åŒ–ã€å¯¹è±¡æ± ä½¿ç”¨
2. **åŠŸèƒ½æ‰©å±•**ï¼šéš¾åº¦ç³»ç»Ÿã€ç»Ÿè®¡ç³»ç»Ÿã€æˆå°±ç³»ç»Ÿ
3. **é…ç½®ç®¡ç†**ï¼šé…ç½®æ–‡ä»¶ã€å¤šè¯­è¨€æ”¯æŒ
4. **ç•Œé¢å¢å¼º**ï¼šå½©è‰²è¾“å‡ºã€è¿›åº¦æ¡ã€åŠ¨ç”»æ•ˆæœ
5. **æ¶æ„ä¼˜åŒ–**ï¼šæ¥å£åˆ†ç¦»ã€ä¾èµ–æ³¨å…¥ã€ä»£ç é‡æ„
6. **é«˜çº§åŠŸèƒ½**ï¼šæ’è¡Œæ¦œã€æ¸¸æˆå›æ”¾ç³»ç»Ÿ

é€šè¿‡è¿™äº›ä¼˜åŒ–å’Œæ‰©å±•ï¼Œæˆ‘ä»¬çš„çŒœæ•°å­—æ¸¸æˆå˜å¾—æ›´åŠ å®Œå–„å’Œä¸“ä¸šã€‚

## ä¸‹ä¸€æ­¥

æ­å–œæ‚¨å®Œæˆäº†æ•´ä¸ªå­¦ä¹ æ–‡æ¡£ï¼ç°åœ¨æ‚¨å·²ç»æŒæ¡äº†ï¼š

- Go è¯­è¨€åŸºç¡€è¯­æ³•å’Œæœ€ä½³å®è·µ
- é¢å‘å¯¹è±¡ç¼–ç¨‹æ€æƒ³
- æµ‹è¯•é©±åŠ¨å¼€å‘æ–¹æ³•
- æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- è½¯ä»¶æ¶æ„è®¾è®¡åŸåˆ™

æ‚¨å¯ä»¥ç»§ç»­æ¢ç´¢ï¼š
- Web å¼€å‘ï¼ˆä½¿ç”¨ Ginã€Echo ç­‰æ¡†æ¶ï¼‰
- æ•°æ®åº“æ“ä½œï¼ˆä½¿ç”¨ GORMã€sqlx ç­‰ï¼‰
- å¾®æœåŠ¡æ¶æ„ï¼ˆä½¿ç”¨ gRPCã€Docker ç­‰ï¼‰
- äº‘åŸç”Ÿå¼€å‘ï¼ˆä½¿ç”¨ Kubernetesã€Istio ç­‰ï¼‰

ç»§ç»­æ‚¨çš„ Go è¯­è¨€å­¦ä¹ ä¹‹æ—…å§ï¼ğŸš€
```
