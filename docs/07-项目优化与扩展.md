# 🚀 项目优化与扩展

本章将学习如何优化猜数字游戏的性能，并扩展更多有趣的功能。

## 1. 性能优化

### 内存优化
```go
// 优化前：每次都创建新的 Scanner
func (g *Game) getPlayerGuess() (int, error) {
    scanner := bufio.NewScanner(os.Stdin) // 每次都创建新实例
    // ...
}

// 优化后：复用 Scanner
type Game struct {
    targetNumber int
    attempts     int
    scanner      *bufio.Scanner // 复用实例
}

func NewGame() *Game {
    return &Game{
        targetNumber: rand.Intn(100) + 1,
        attempts:     0,
        scanner:      bufio.NewScanner(os.Stdin), // 只创建一次
    }
}
```

### 字符串操作优化
```go
import (
    "strings"
    "bytes"
)

// 优化前：频繁的字符串拼接
func createBorder(width int) string {
    result := ""
    for i := 0; i < width; i++ {
        result += "="  // 每次拼接都会创建新字符串
    }
    return result
}

// 优化后：使用 strings.Repeat
func createBorderOptimized(width int) string {
    return strings.Repeat("=", width)
}

// 或者使用 bytes.Buffer 进行复杂拼接
func createComplexString(parts []string) string {
    var buffer bytes.Buffer
    for _, part := range parts {
        buffer.WriteString(part)
    }
    return buffer.String()
}
```

### 随机数生成优化
```go
import (
    "math/rand"
    "sync"
    "time"
)

// 线程安全的随机数生成器
type SafeRandom struct {
    rng *rand.Rand
    mu  sync.Mutex
}

func NewSafeRandom() *SafeRandom {
    return &SafeRandom{
        rng: rand.New(rand.NewSource(time.Now().UnixNano())),
    }
}

func (sr *SafeRandom) Intn(n int) int {
    sr.mu.Lock()
    defer sr.mu.Unlock()
    return sr.rng.Intn(n)
}

// 使用对象池减少内存分配
var gamePool = sync.Pool{
    New: func() interface{} {
        return &Game{}
    },
}

func NewGameFromPool() *Game {
    game := gamePool.Get().(*Game)
    game.reset()
    return game
}

func (g *Game) reset() {
    g.targetNumber = rand.Intn(100) + 1
    g.attempts = 0
}

func (g *Game) Release() {
    gamePool.Put(g)
}
```

## 2. 功能扩展

### 难度级别系统
```go
type Difficulty int

const (
    Easy Difficulty = iota
    Medium
    Hard
    Expert
)

type DifficultyConfig struct {
    Name      string
    MinNumber int
    MaxNumber int
    MaxHints  int
}

var difficultyConfigs = map[Difficulty]DifficultyConfig{
    Easy:   {"简单", 1, 50, 3},
    Medium: {"中等", 1, 100, 2},
    Hard:   {"困难", 1, 200, 1},
    Expert: {"专家", 1, 500, 0},
}

type EnhancedGame struct {
    targetNumber int
    attempts     int
    difficulty   Difficulty
    hintsUsed    int
    scanner      *bufio.Scanner
}

func NewEnhancedGame(diff Difficulty) *EnhancedGame {
    config := difficultyConfigs[diff]
    rand.Seed(time.Now().UnixNano())
    
    return &EnhancedGame{
        targetNumber: rand.Intn(config.MaxNumber-config.MinNumber+1) + config.MinNumber,
        attempts:     0,
        difficulty:   diff,
        hintsUsed:    0,
        scanner:      bufio.NewScanner(os.Stdin),
    }
}

func (g *EnhancedGame) GetHint() string {
    config := difficultyConfigs[g.difficulty]
    if g.hintsUsed >= config.MaxHints {
        return "已达到最大提示次数"
    }
    
    g.hintsUsed++
    
    // 根据已使用的提示次数提供不同级别的提示
    switch g.hintsUsed {
    case 1:
        if g.targetNumber%2 == 0 {
            return "💡 提示1：目标数字是偶数"
        }
        return "💡 提示1：目标数字是奇数"
    case 2:
        if g.targetNumber <= (config.MaxNumber-config.MinNumber)/2+config.MinNumber {
            return "💡 提示2：目标数字在较小的一半范围内"
        }
        return "💡 提示2：目标数字在较大的一半范围内"
    case 3:
        return fmt.Sprintf("💡 提示3：目标数字的十位数是 %d", g.targetNumber/10)
    default:
        return "没有更多提示了"
    }
}
```

### 游戏统计系统
```go
import (
    "encoding/json"
    "os"
    "time"
)

type GameStats struct {
    TotalGames      int                    `json:"total_games"`
    TotalWins       int                    `json:"total_wins"`
    TotalAttempts   int                    `json:"total_attempts"`
    BestScore       int                    `json:"best_score"`
    AverageAttempts float64               `json:"average_attempts"`
    DifficultyStats map[Difficulty]DifficultyStats `json:"difficulty_stats"`
    LastPlayed      time.Time             `json:"last_played"`
}

type DifficultyStats struct {
    Games    int     `json:"games"`
    Wins     int     `json:"wins"`
    BestScore int    `json:"best_score"`
    WinRate  float64 `json:"win_rate"`
}

func NewGameStats() *GameStats {
    return &GameStats{
        DifficultyStats: make(map[Difficulty]DifficultyStats),
    }
}

func (gs *GameStats) AddGame(difficulty Difficulty, attempts int, won bool) {
    gs.TotalGames++
    gs.TotalAttempts += attempts
    gs.LastPlayed = time.Now()
    
    if won {
        gs.TotalWins++
        if gs.BestScore == 0 || attempts < gs.BestScore {
            gs.BestScore = attempts
        }
    }
    
    // 更新平均猜测次数
    gs.AverageAttempts = float64(gs.TotalAttempts) / float64(gs.TotalGames)
    
    // 更新难度统计
    diffStats := gs.DifficultyStats[difficulty]
    diffStats.Games++
    if won {
        diffStats.Wins++
        if diffStats.BestScore == 0 || attempts < diffStats.BestScore {
            diffStats.BestScore = attempts
        }
    }
    diffStats.WinRate = float64(diffStats.Wins) / float64(diffStats.Games)
    gs.DifficultyStats[difficulty] = diffStats
}

func (gs *GameStats) SaveToFile(filename string) error {
    data, err := json.MarshalIndent(gs, "", "  ")
    if err != nil {
        return err
    }
    return os.WriteFile(filename, data, 0644)
}

func LoadGameStats(filename string) (*GameStats, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        if os.IsNotExist(err) {
            return NewGameStats(), nil
        }
        return nil, err
    }
    
    var stats GameStats
    err = json.Unmarshal(data, &stats)
    if err != nil {
        return nil, err
    }
    
    if stats.DifficultyStats == nil {
        stats.DifficultyStats = make(map[Difficulty]DifficultyStats)
    }
    
    return &stats, nil
}

func (gs *GameStats) DisplayStats() {
    fmt.Println("\n📊 游戏统计")
    fmt.Println(strings.Repeat("=", 40))
    fmt.Printf("总游戏次数: %d\n", gs.TotalGames)
    fmt.Printf("获胜次数: %d\n", gs.TotalWins)
    fmt.Printf("胜率: %.1f%%\n", float64(gs.TotalWins)/float64(gs.TotalGames)*100)
    fmt.Printf("最佳成绩: %d 次\n", gs.BestScore)
    fmt.Printf("平均猜测次数: %.1f\n", gs.AverageAttempts)
    fmt.Printf("上次游戏: %s\n", gs.LastPlayed.Format("2006-01-02 15:04:05"))

    fmt.Println("\n各难度统计:")
    for diff, stats := range gs.DifficultyStats {
        config := difficultyConfigs[diff]
        fmt.Printf("  %s: %d局 胜率%.1f%% 最佳%d次\n",
            config.Name, stats.Games, stats.WinRate*100, stats.BestScore)
    }
}

### 成就系统
```go
type Achievement struct {
    ID          string `json:"id"`
    Name        string `json:"name"`
    Description string `json:"description"`
    Unlocked    bool   `json:"unlocked"`
    UnlockedAt  time.Time `json:"unlocked_at"`
}

type AchievementManager struct {
    achievements map[string]*Achievement
    stats        *GameStats
}

func NewAchievementManager(stats *GameStats) *AchievementManager {
    am := &AchievementManager{
        achievements: make(map[string]*Achievement),
        stats:        stats,
    }
    am.initializeAchievements()
    return am
}

func (am *AchievementManager) initializeAchievements() {
    achievements := []*Achievement{
        {"first_win", "初次胜利", "赢得第一场游戏", false, time.Time{}},
        {"quick_win", "神速猜中", "在3次内猜中数字", false, time.Time{}},
        {"persistent", "坚持不懈", "完成10场游戏", false, time.Time{}},
        {"master", "猜数大师", "在困难模式下获胜", false, time.Time{}},
        {"perfect", "完美表现", "连续5场游戏获胜", false, time.Time{}},
    }

    for _, achievement := range achievements {
        am.achievements[achievement.ID] = achievement
    }
}

func (am *AchievementManager) CheckAchievements(difficulty Difficulty, attempts int, won bool) []string {
    var newAchievements []string

    // 检查各种成就条件
    if won && !am.achievements["first_win"].Unlocked && am.stats.TotalWins == 1 {
        am.unlockAchievement("first_win")
        newAchievements = append(newAchievements, "first_win")
    }

    if won && attempts <= 3 && !am.achievements["quick_win"].Unlocked {
        am.unlockAchievement("quick_win")
        newAchievements = append(newAchievements, "quick_win")
    }

    if am.stats.TotalGames >= 10 && !am.achievements["persistent"].Unlocked {
        am.unlockAchievement("persistent")
        newAchievements = append(newAchievements, "persistent")
    }

    if won && difficulty == Hard && !am.achievements["master"].Unlocked {
        am.unlockAchievement("master")
        newAchievements = append(newAchievements, "master")
    }

    return newAchievements
}

func (am *AchievementManager) unlockAchievement(id string) {
    if achievement, exists := am.achievements[id]; exists {
        achievement.Unlocked = true
        achievement.UnlockedAt = time.Now()
    }
}

func (am *AchievementManager) DisplayAchievements() {
    fmt.Println("\n🏆 成就系统")
    fmt.Println(strings.Repeat("=", 40))

    for _, achievement := range am.achievements {
        status := "🔒"
        timeStr := ""
        if achievement.Unlocked {
            status = "✅"
            timeStr = fmt.Sprintf(" (%s)", achievement.UnlockedAt.Format("2006-01-02"))
        }

        fmt.Printf("%s %s: %s%s\n",
            status, achievement.Name, achievement.Description, timeStr)
    }
}

## 3. 配置系统

### 配置文件管理
```go
import (
    "encoding/json"
    "os"
)

type GameConfig struct {
    DefaultDifficulty Difficulty `json:"default_difficulty"`
    AutoSave         bool       `json:"auto_save"`
    SoundEnabled     bool       `json:"sound_enabled"`
    Language         string     `json:"language"`
    Theme            string     `json:"theme"`
    MaxAttempts      int        `json:"max_attempts"`
}

func DefaultConfig() *GameConfig {
    return &GameConfig{
        DefaultDifficulty: Medium,
        AutoSave:         true,
        SoundEnabled:     false,
        Language:         "zh-CN",
        Theme:            "default",
        MaxAttempts:      0, // 0 表示无限制
    }
}

func LoadConfig(filename string) (*GameConfig, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        if os.IsNotExist(err) {
            return DefaultConfig(), nil
        }
        return nil, err
    }

    var config GameConfig
    err = json.Unmarshal(data, &config)
    if err != nil {
        return nil, err
    }

    return &config, nil
}

func (gc *GameConfig) SaveToFile(filename string) error {
    data, err := json.MarshalIndent(gc, "", "  ")
    if err != nil {
        return err
    }
    return os.WriteFile(filename, data, 0644)
}

## 4. 多语言支持

### 国际化系统
```go
type Localizer struct {
    language string
    messages map[string]map[string]string
}

func NewLocalizer(language string) *Localizer {
    l := &Localizer{
        language: language,
        messages: make(map[string]map[string]string),
    }
    l.loadMessages()
    return l
}

func (l *Localizer) loadMessages() {
    // 中文消息
    l.messages["zh-CN"] = map[string]string{
        "welcome":           "欢迎来到猜数字游戏！",
        "game_start":        "我已经想好了一个 %d-%d 之间的数字，请开始猜测：",
        "input_prompt":      "请输入你的猜测：",
        "too_high":          "太大了！请再试一次。",
        "too_low":           "太小了！请再试一次。",
        "correct":           "恭喜你！猜对了！你总共猜了 %d 次。",
        "continue_game":     "是否继续游戏？(y/n)：",
        "goodbye":           "感谢游戏！再见！👋",
        "invalid_input":     "输入错误：%v，请重新输入。",
        "new_game":          "开始新游戏！",
    }

    // 英文消息
    l.messages["en-US"] = map[string]string{
        "welcome":           "Welcome to the Number Guessing Game!",
        "game_start":        "I'm thinking of a number between %d and %d. Start guessing:",
        "input_prompt":      "Enter your guess: ",
        "too_high":          "Too high! Try again.",
        "too_low":           "Too low! Try again.",
        "correct":           "Congratulations! You got it in %d attempts!",
        "continue_game":     "Continue playing? (y/n): ",
        "goodbye":           "Thanks for playing! Goodbye! 👋",
        "invalid_input":     "Input error: %v, please try again.",
        "new_game":          "Starting new game!",
    }
}

func (l *Localizer) Get(key string, args ...interface{}) string {
    if langMessages, exists := l.messages[l.language]; exists {
        if message, exists := langMessages[key]; exists {
            if len(args) > 0 {
                return fmt.Sprintf(message, args...)
            }
            return message
        }
    }

    // 回退到英文
    if langMessages, exists := l.messages["en-US"]; exists {
        if message, exists := langMessages[key]; exists {
            if len(args) > 0 {
                return fmt.Sprintf(message, args...)
            }
            return message
        }
    }

    return key // 如果都找不到，返回键名
}

## 5. 命令行界面增强

### 彩色输出
```go
import (
    "fmt"
)

// ANSI 颜色代码
const (
    ColorReset  = "\033[0m"
    ColorRed    = "\033[31m"
    ColorGreen  = "\033[32m"
    ColorYellow = "\033[33m"
    ColorBlue   = "\033[34m"
    ColorPurple = "\033[35m"
    ColorCyan   = "\033[36m"
    ColorWhite  = "\033[37m"
)

type ColorPrinter struct {
    enabled bool
}

func NewColorPrinter(enabled bool) *ColorPrinter {
    return &ColorPrinter{enabled: enabled}
}

func (cp *ColorPrinter) Printf(color, format string, args ...interface{}) {
    if cp.enabled {
        fmt.Printf(color+format+ColorReset, args...)
    } else {
        fmt.Printf(format, args...)
    }
}

func (cp *ColorPrinter) Success(format string, args ...interface{}) {
    cp.Printf(ColorGreen, format, args...)
}

func (cp *ColorPrinter) Error(format string, args ...interface{}) {
    cp.Printf(ColorRed, format, args...)
}

func (cp *ColorPrinter) Warning(format string, args ...interface{}) {
    cp.Printf(ColorYellow, format, args...)
}

func (cp *ColorPrinter) Info(format string, args ...interface{}) {
    cp.Printf(ColorBlue, format, args...)
}

### 进度条和动画
```go
import (
    "time"
)

type Spinner struct {
    chars []string
    delay time.Duration
}

func NewSpinner() *Spinner {
    return &Spinner{
        chars: []string{"|", "/", "-", "\\"},
        delay: 100 * time.Millisecond,
    }
}

func (s *Spinner) Start(message string) chan bool {
    stop := make(chan bool)

    go func() {
        i := 0
        for {
            select {
            case <-stop:
                fmt.Print("\r" + strings.Repeat(" ", len(message)+5) + "\r")
                return
            default:
                fmt.Printf("\r%s %s", s.chars[i%len(s.chars)], message)
                i++
                time.Sleep(s.delay)
            }
        }
    }()

    return stop
}

// 使用示例
func loadGameWithSpinner() {
    spinner := NewSpinner()
    stop := spinner.Start("正在加载游戏...")

    // 模拟加载过程
    time.Sleep(2 * time.Second)

    stop <- true
    fmt.Println("游戏加载完成！")
}

## 6. 代码重构和架构优化

### 接口分离
```go
// 游戏核心接口
type GameEngine interface {
    Start()
    CheckGuess(guess int) int
    IsGameOver() bool
    GetAttempts() int
}

// 用户交互接口
type UserInterface interface {
    GetInput() (int, error)
    ShowMessage(message string)
    ShowError(err error)
    ShowStats(stats *GameStats)
}

// 数据持久化接口
type DataPersistence interface {
    SaveStats(stats *GameStats) error
    LoadStats() (*GameStats, error)
    SaveConfig(config *GameConfig) error
    LoadConfig() (*GameConfig, error)
}

// 具体实现
type ConsoleUI struct {
    scanner *bufio.Scanner
    printer *ColorPrinter
    localizer *Localizer
}

func NewConsoleUI(printer *ColorPrinter, localizer *Localizer) *ConsoleUI {
    return &ConsoleUI{
        scanner:   bufio.NewScanner(os.Stdin),
        printer:   printer,
        localizer: localizer,
    }
}

func (cui *ConsoleUI) GetInput() (int, error) {
    cui.printer.Info(cui.localizer.Get("input_prompt"))

    if !cui.scanner.Scan() {
        return 0, fmt.Errorf("读取输入失败")
    }

    input := strings.TrimSpace(cui.scanner.Text())
    if input == "" {
        return 0, fmt.Errorf("输入不能为空")
    }

    guess, err := strconv.Atoi(input)
    if err != nil {
        return 0, fmt.Errorf("请输入一个有效的数字")
    }

    return guess, nil
}

func (cui *ConsoleUI) ShowMessage(message string) {
    cui.printer.Info("%s\n", message)
}

func (cui *ConsoleUI) ShowError(err error) {
    cui.printer.Error("❌ %v\n", err)
}

### 依赖注入容器
```go
type Container struct {
    services map[string]interface{}
}

func NewContainer() *Container {
    return &Container{
        services: make(map[string]interface{}),
    }
}

func (c *Container) Register(name string, service interface{}) {
    c.services[name] = service
}

func (c *Container) Get(name string) interface{} {
    return c.services[name]
}

func (c *Container) GetGameEngine() GameEngine {
    return c.Get("game_engine").(GameEngine)
}

func (c *Container) GetUserInterface() UserInterface {
    return c.Get("user_interface").(UserInterface)
}

func (c *Container) GetDataPersistence() DataPersistence {
    return c.Get("data_persistence").(DataPersistence)
}

// 应用程序启动器
type Application struct {
    container *Container
}

func NewApplication() *Application {
    app := &Application{
        container: NewContainer(),
    }
    app.setupDependencies()
    return app
}

func (app *Application) setupDependencies() {
    // 配置服务
    config := DefaultConfig()
    app.container.Register("config", config)

    // 本地化服务
    localizer := NewLocalizer(config.Language)
    app.container.Register("localizer", localizer)

    // 颜色打印服务
    printer := NewColorPrinter(true)
    app.container.Register("printer", printer)

    // 用户界面服务
    ui := NewConsoleUI(printer, localizer)
    app.container.Register("user_interface", ui)

    // 游戏引擎服务
    game := NewEnhancedGame(config.DefaultDifficulty)
    app.container.Register("game_engine", game)

    // 数据持久化服务
    persistence := NewFilePersistence("game_data.json", "game_config.json")
    app.container.Register("data_persistence", persistence)
}

func (app *Application) Run() {
    ui := app.container.GetUserInterface()
    engine := app.container.GetGameEngine()

    ui.ShowMessage("欢迎来到猜数字游戏！")

    for {
        engine.Start()

        // 询问是否继续...
        // 游戏主循环逻辑
    }
}

## 7. 实践练习

### 练习1：实现排行榜系统
```go
type LeaderboardEntry struct {
    PlayerName string    `json:"player_name"`
    Score      int       `json:"score"`
    Difficulty Difficulty `json:"difficulty"`
    Date       time.Time `json:"date"`
}

type Leaderboard struct {
    entries []LeaderboardEntry
    maxSize int
}

func NewLeaderboard(maxSize int) *Leaderboard {
    return &Leaderboard{
        entries: make([]LeaderboardEntry, 0),
        maxSize: maxSize,
    }
}

func (lb *Leaderboard) AddEntry(entry LeaderboardEntry) {
    lb.entries = append(lb.entries, entry)

    // 按分数排序（分数越低越好）
    sort.Slice(lb.entries, func(i, j int) bool {
        return lb.entries[i].Score < lb.entries[j].Score
    })

    // 保持最大条目数
    if len(lb.entries) > lb.maxSize {
        lb.entries = lb.entries[:lb.maxSize]
    }
}

func (lb *Leaderboard) Display() {
    fmt.Println("\n🏆 排行榜")
    fmt.Println(strings.Repeat("=", 50))

    for i, entry := range lb.entries {
        rank := i + 1
        diffName := difficultyConfigs[entry.Difficulty].Name
        fmt.Printf("%d. %s - %d次 (%s) %s\n",
            rank, entry.PlayerName, entry.Score, diffName,
            entry.Date.Format("2006-01-02"))
    }
}
```

### 练习2：实现游戏回放系统
```go
type GameMove struct {
    Guess     int       `json:"guess"`
    Result    int       `json:"result"`
    Timestamp time.Time `json:"timestamp"`
}

type GameReplay struct {
    GameID       string     `json:"game_id"`
    TargetNumber int        `json:"target_number"`
    Difficulty   Difficulty `json:"difficulty"`
    Moves        []GameMove `json:"moves"`
    StartTime    time.Time  `json:"start_time"`
    EndTime      time.Time  `json:"end_time"`
    Won          bool       `json:"won"`
}

func (gr *GameReplay) AddMove(guess, result int) {
    move := GameMove{
        Guess:     guess,
        Result:    result,
        Timestamp: time.Now(),
    }
    gr.Moves = append(gr.Moves, move)
}

func (gr *GameReplay) PlayReplay() {
    fmt.Printf("回放游戏 %s\n", gr.GameID)
    fmt.Printf("目标数字: %d, 难度: %s\n",
        gr.TargetNumber, difficultyConfigs[gr.Difficulty].Name)

    for i, move := range gr.Moves {
        fmt.Printf("第%d次猜测: %d -> ", i+1, move.Guess)
        switch move.Result {
        case 0:
            fmt.Println("猜对了！")
        case 1:
            fmt.Println("太大了")
        case -1:
            fmt.Println("太小了")
        }
        time.Sleep(500 * time.Millisecond) // 模拟回放速度
    }
}
```

## 小结

本章学习了：

1. **性能优化**：内存优化、字符串操作优化、对象池使用
2. **功能扩展**：难度系统、统计系统、成就系统
3. **配置管理**：配置文件、多语言支持
4. **界面增强**：彩色输出、进度条、动画效果
5. **架构优化**：接口分离、依赖注入、代码重构
6. **高级功能**：排行榜、游戏回放系统

通过这些优化和扩展，我们的猜数字游戏变得更加完善和专业。

## 下一步

恭喜您完成了整个学习文档！现在您已经掌握了：

- Go 语言基础语法和最佳实践
- 面向对象编程思想
- 测试驱动开发方法
- 性能优化技巧
- 软件架构设计原则

您可以继续探索：
- Web 开发（使用 Gin、Echo 等框架）
- 数据库操作（使用 GORM、sqlx 等）
- 微服务架构（使用 gRPC、Docker 等）
- 云原生开发（使用 Kubernetes、Istio 等）

继续您的 Go 语言学习之旅吧！🚀
```
